export class Recorder {
    constructor(srInstrument: any);
    triggerHistory: any[];
    /** The parent classes that share the recorder */
    srInstrument: any;
    ee: any;
    srFeatureName: any;
    agentRef: any;
    isErrorMode: boolean;
    /** A flag that can be set to false by failing conversions to stop the fetching process */
    shouldFix: any;
    /** Each page mutation or event will be stored (raw) in this array. This array will be cleared on each harvest */
    events: RecorderEvents;
    /** Backlog used for a 2-part sliding window to guarantee a 15-30s buffer window */
    backloggedEvents: RecorderEvents;
    /** Only set to true once a snapshot node has been processed.  Used to block harvests from sending before we know we have a snapshot */
    hasSeenSnapshot: boolean;
    /** Hold on to the last meta node, so that it can be re-inserted if the meta and snapshot nodes are broken up due to harvesting */
    lastMeta: boolean;
    /** The method to stop recording. This defaults to a noop, but is overwritten once the recording library is imported and initialized */
    stopRecording: () => void;
    get trigger(): any;
    getEvents(): {
        events: any[];
        type: string;
        cycleTimestamp: number;
        payloadBytesEstimation: number;
        hasError: boolean;
        hasMeta: boolean;
        hasSnapshot: boolean;
        inlinedAllStylesheets: boolean;
    };
    /** Clears the buffer (this.events), and resets all payload metadata properties */
    clearBuffer(): void;
    /** Begin recording using configured recording lib */
    startRecording(trigger: any, mode: any): void;
    /**
     * audit - Checks if the event node payload is missing certain attributes
     * will forward on to the "store" method if nothing needs async fixing
     * @param {*} event - An RRWEB event node
     * @param {*} isCheckout - Flag indicating if the payload was triggered as a checkout
     */
    audit(event: any, isCheckout: any): void;
    /** Store a payload in the buffer (this.events).  This should be the callback to the recording lib noticing a mutation */
    store(event: any, isCheckout: any): void;
    /** force the recording lib to take a full DOM snapshot.  This needs to occur in certain cases, like visibility changes */
    takeFullSnapshot(): void;
    clearTimestamps(): void;
    /** Estimate the payload size */
    getPayloadSize(newBytes?: number): any;
    /** Extensive research has yielded about an 88% compression factor on these payloads.
     * This is an estimation using that factor as to not cause performance issues while evaluating
     * https://staging.onenr.io/037jbJWxbjy
     * */
    estimateCompression(data: any): any;
    #private;
}
import { RecorderEvents } from './recorder-events';
//# sourceMappingURL=recorder.d.ts.map