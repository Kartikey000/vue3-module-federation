/**
 * @typedef {import('./compute-stack-trace.js').StackInfo} StackInfo
 */
export class Aggregate extends AggregateBase {
    static featureName: string;
    constructor(agentRef: any);
    stackReported: {};
    observedAt: {};
    pageviewReported: {};
    bufferedErrorsUnderSpa: {};
    errorOnPage: boolean;
    serializer(aggregatorTypeToBucketsMap: any): Object;
    queryStringsBuilder(aggregatorTakeReturnedData: any): {
        ri: string;
        pve: string;
    };
    /**
     * Builds a standardized stack trace string from the frames in the given `stackInfo` object, with each frame separated
     * by a newline character. Lines take the form `<functionName>@<url>:<lineNumber>`.
     *
     * @param {StackInfo} stackInfo - An object specifying a stack string and individual frames.
     * @returns {string} A canonical stack string built from the URLs and function names in the given `stackInfo` object.
     */
    buildCanonicalStackString(stackInfo: StackInfo): string;
    /**
     *
     * @param {Error|UncaughtError} err The error instance to be processed
     * @param {number} time the relative ms (to origin) timestamp of occurence
     * @param {boolean=} internal if the error was "caught" and deemed "internal" before reporting to the jserrors feature
     * @param {object=} customAttributes  any custom attributes to be included in the error payload
     * @param {boolean=} hasReplay a flag indicating if the error occurred during a replay session
     * @param {string=} swallowReason a string indicating pre-defined reason if swallowing the error.  Mainly used by the internal error SMs.
     * @param {object=} target the target to buffer and harvest to, if undefined the default configuration target is used
     * @returns
     */
    storeError(err: Error | UncaughtError, time: number, internal?: boolean | undefined, customAttributes?: object | undefined, hasReplay?: boolean | undefined, swallowReason?: string | undefined, targetEntityGuid: any): void;
    /**
    * If the event lacks an entityGuid (the default behavior), the main agent should capture the data. If the data is assigned to a sub-entity target
    * the main agent should not capture events unless it is configured to do so.
    * @param {string} entityGuid - the context object for the event
    * @returns {boolean} - whether the main agent should capture the event to its internal target
    */
    shouldAllowMainAgentToCapture(entityGuid: string): boolean;
    onInteractionDone(interaction: any, wasSaved: any): void;
    onSoftNavNotification(interactionId: any, wasFinished: any, softNavAttrs: any, interactionEndTime: any): void;
    #private;
}
export type StackInfo = import("./compute-stack-trace.js").StackInfo;
import { AggregateBase } from '../../utils/aggregate-base';
//# sourceMappingURL=index.d.ts.map