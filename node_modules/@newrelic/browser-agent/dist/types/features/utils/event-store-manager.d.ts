/**
 * This layer allows multiple browser entity apps, or "target", to each have their own segregated storage instance.
 * The purpose is so the harvester can send data to different apps within the same agent. Each feature should have a manager if it needs this capability.
 */
export class EventStoreManager {
    /**
     * @param {object} agentRef - reference to base agent class
     * @param {EventBuffer|EventAggregator} storageClass - the type of storage to use in this manager; 'EventBuffer' (1), 'EventAggregator' (2)
     * @param {string} [defaultEntityGuid] - the entity guid to use as the default storage instance; if not provided, a new one is created
     * @param {Object} featureAgg - the feature aggregate instance that initialized this manager
     */
    constructor(agentRef: object, storageClass: EventBuffer | EventAggregator, defaultEntityGuid?: string, featureAgg: Object);
    agentRef: object;
    entityManager: any;
    StorageClass: any;
    appStorageMap: Map<string, any>;
    featureAgg: Object;
    setEventStore(targetEntityGuid: any): void;
    /** IMPORTANT
     * This class must contain an union of all methods from all supported storage classes and conceptualize away the target app argument.
     */
    get length(): any;
    /**
     * Calls the merge method on the underlying storage class.
     * @param {*} matcher
     * @param {*} data
     * @param {*} targetEntityGuid
     * @returns {boolean} True if the merge was successful
     */
    merge(matcher: any, data: any, targetEntityGuid: any): boolean;
    /**
     * Calls the isEmpty method on the underlying storage class. If target is provided, runs just for the target, otherwise runs for all apps.
     * @param {object} optsIfPresent - exists if called during harvest interval, @see AggregateBase.makeHarvestPayload
     * @param {object} target - specific app's storage to check; if not provided, this method takes into account all apps recorded by this manager
     * @returns {boolean} True if the target's storage is empty, or target does not exist in map (defaults to all storages)
     */
    isEmpty(optsIfPresent: object, targetEntityGuid: any): boolean;
    /**
     * Calls the add method on the underlying storage class.
     * @param {string} event - the event element to store
     * @param {object} targetEntityGuid - the entity guid lookup to store event under; if not provided, this method adds to the default
     * @returns {boolean} True if the event was successfully added
     */
    add(event: string, targetEntityGuid: object): boolean;
    /** This is only used by the Metrics feature which has no need to add metric under a different app atm. */
    addMetric(type: any, name: any, params: any, value: any): any;
    /**
     * Calls the get method on the underlying storage class. If target is provided, runs just for the target, otherwise runs for all apps.
     * @param {object=} opts - exists if called during harvest interval, @see AggregateBase.makeHarvestPayload
     * @param {object=} target - specific app to fetch; if not provided, this method fetches from all apps
     * @returns {Array} Objects of `data` labeled with their respective `target` app to be sent to
     */
    get(opts?: object | undefined, targetEntityGuid: any): any[];
    /**
     * Calls the byteSize method on the underlying storage class
     * @param {*} targetEntityGuid
     * @returns
     */
    byteSize(targetEntityGuid: any): any;
    /**
     * Calls the wouldExceedMaxSize method on the underlying storage class
     * @param {*} incomingSize
     * @param {*} targetEntityGuid
     * @returns
     */
    wouldExceedMaxSize(incomingSize: any, targetEntityGuid: any): any;
    /**
     * Calls the save method on the underlying storage class. If target is provided, runs just for the target, otherwise runs for all apps.
     * @param {*} optsIfPresent
     * @param {*} targetEntityGuid
     * @returns
     */
    save(optsIfPresent: any, targetEntityGuid: any): any;
    /**
     * Calls the clear method on the underlying storage class. If target is provided, runs just for the target, otherwise runs for all apps.
     * @param {*} optsIfPresent
     * @param {*} targetEntityGuid
     * @returns
     */
    clear(optsIfPresent: any, targetEntityGuid: any): any;
    reloadSave(optsIfPresent: any, targetEntityGuid: any): any;
    clearSave(optsIfPresent: any, targetEntityGuid: any): any;
    #private;
}
//# sourceMappingURL=event-store-manager.d.ts.map