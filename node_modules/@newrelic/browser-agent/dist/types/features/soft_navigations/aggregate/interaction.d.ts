/**
 * link https://github.com/newrelic/nr-querypack/blob/main/schemas/bel/7.qpschema
 **/
export class Interaction extends BelNode {
    constructor(uiEvent: any, uiEventTimestamp: any, currentRouteKnown: any, currentUrl: any);
    id: string;
    initialPageURL: string;
    customName: any;
    customAttributes: {};
    customDataByApi: {};
    queueTime: any;
    appTime: any;
    newRoute: any;
    /** Internal state of this interaction: in-progress, finished, or cancelled. */
    status: string;
    domTimestamp: number;
    historyTimestamp: number;
    createdByApi: boolean;
    keepOpenUntilEndApi: boolean;
    onDone: any[];
    customEnd: number;
    cancellationTimer: any;
    watchLongtaskTimer: any;
    belType: number;
    trigger: any;
    oldRoute: any;
    eventSubscription: Map<string, never[]>;
    forceSave: boolean;
    forceIgnore: boolean;
    newURL: any;
    oldURL: any;
    updateHistory(timestamp: any, newUrl: any): void;
    updateDom(timestamp: any): void;
    checkHistoryAndDomChange(): boolean;
    on(event: any, cb: any): void;
    done(customEndTime?: number, calledByApi?: boolean): boolean;
    /**
     * Given a timestamp, determine if it falls within this interaction's span, i.e. if this was the active interaction during that time.
     * For in-progress interactions, this only compares the time with the start of span. Cancelled interactions are not considered active at all.
     * Pending-finish interactions are also considered still active wrt assigning ajax or jserrors to them during the wait period.
     * @param {DOMHighResTimeStamp} timestamp
     * @returns True or false boolean.
     */
    isActiveDuring(timestamp: DOMHighResTimeStamp): boolean;
    get firstPaint(): void;
    get firstContentfulPaint(): void;
    get navTiming(): void;
    /**
     * Serializes (BEL) the interaction data for transmission.
     * @param {Number} firstStartTimeOfPayload timestamp
     * @param {Agent} agentRef Pass in the agent reference directly so that the event itself doesnt need to store the pointers and ruin the evaluation of the event size by including unused object references.
     * @returns {String} A string that is the serialized representation of this interaction.
     */
    serialize(firstStartTimeOfPayload: number, agentRef: Agent): string;
    #private;
}
import { BelNode } from './bel-node';
//# sourceMappingURL=interaction.d.ts.map