"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MicroAgent = void 0;
var _instrument = require("../features/page_view_event/instrument");
var _enabledFeatures = require("./features/enabled-features");
var _configure = require("./configure/configure");
var _nreum = require("../common/window/nreum");
var _features = require("./features/features");
var _console = require("../common/util/console");
var _microAgentBase = require("./micro-agent-base");
var _setCustomAttribute = require("./api/setCustomAttribute");
var _setUserId = require("./api/setUserId");
var _setApplicationVersion = require("./api/setApplicationVersion");
var _start = require("./api/start");
var _noticeError = require("./api/noticeError");
var _setErrorHandler = require("./api/setErrorHandler");
var _addRelease = require("./api/addRelease");
var _addPageAction = require("./api/addPageAction");
var _recordCustomEvent = require("./api/recordCustomEvent");
var _finished = require("./api/finished");
var _log = require("./api/log");
var _wrapLogger = require("./api/wrapLogger");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; } /**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */ // loader files
// core files
// api files that are not auto-instrumented
const nonAutoFeatures = [_features.FEATURE_NAMES.jserrors, _features.FEATURE_NAMES.genericEvents, _features.FEATURE_NAMES.metrics, _features.FEATURE_NAMES.logging];

/**
 * A minimal agent class designed to only respond to manual user input. As such, this class does not
 * automatically instrument. Instead, each MicroAgent instance will lazy load the required features and can support loading multiple instances on one page.
 * Out of the box, it can manually handle and report Page View, Page Action, and Error events.
 *
 * @note This loader strategy is slated to be deprecated and eventually removed in a future product release. For better memory usage, build size impacts, entity management and relationships -- a new strategy focused around using a single centralized browser agent instance is actively being worked on. Reach out by email to browser-agent@newrelic.com for more information or if you would like to participate in a limited preview when the feature is ready for early adoption.
 *
 * @see {@link https://www.npmjs.com/package/@newrelic/browser-agent#deploying-one-or-more-micro-agents-per-page} for more information in the documentation.
 */
class MicroAgent extends _microAgentBase.MicroAgentBase {
  /**
   * @param {import('./agent').AgentOptions} options
   */
  constructor(options) {
    super();
    this.features = {};
    (0, _nreum.setNREUMInitializedAgent)(this.agentIdentifier, this);
    (0, _configure.configure)(this, {
      ...options,
      runtime: {
        isolatedBacklog: true
      }
    }, options.loaderType || 'micro-agent');

    /** assign base agent-level API definitions */
    (0, _setCustomAttribute.setupSetCustomAttributeAPI)(this);
    (0, _setUserId.setupSetUserIdAPI)(this);
    (0, _setApplicationVersion.setupSetApplicationVersionAPI)(this);
    (0, _start.setupStartAPI)(this);

    /** feature APIs that wont get set up automatically for the micro agent since it skips the inst file */
    /** jserrors */
    (0, _noticeError.setupNoticeErrorAPI)(this);
    (0, _setErrorHandler.setupSetErrorHandlerAPI)(this);
    (0, _addRelease.setupAddReleaseAPI)(this);
    /** generic events */
    (0, _addPageAction.setupAddPageActionAPI)(this);
    (0, _recordCustomEvent.setupRecordCustomEventAPI)(this);
    (0, _finished.setupFinishedAPI)(this);
    /** logging */
    (0, _log.setupLogAPI)(this);
    (0, _wrapLogger.setupWrapLoggerAPI)(this);

    /**
     * Starts a set of agent features if not running in "autoStart" mode
     * {@link https://docs.newrelic.com/docs/browser/new-relic-browser/browser-apis/start/}
     * @param {string|string[]} [featureNames] The feature name(s) to start.  If no name(s) are passed, all features will be started
     */
    this.start = featureNames => {
      try {
        if (featureNames === undefined || Array.isArray(featureNames) && featureNames.length === 0) featureNames = nonAutoFeatures;else if (typeof featureNames === 'string') featureNames = [featureNames];
        if (featureNames.some(f => !nonAutoFeatures.includes(f))) (0, _console.warn)(37, nonAutoFeatures);
        const enabledFeatures = (0, _enabledFeatures.getEnabledFeatures)(this.init);
        try {
          // a biproduct of doing this is that the "session manager" is automatically handled through importing this feature
          this.features.page_view_event = new _instrument.Instrument(this);
        } catch (err) {
          (0, _console.warn)(24, err);
        }
        this.features.page_view_event.onAggregateImported.then(() => {
          /* The following features do not import an "instrument" file, meaning they are only hooked up to the API.
          Since the missing instrument-base class handles drain-gating (racing behavior) and PVE handles some setup, these are chained until after PVE has finished initializing
          so as to avoid the race condition of things like session and sharedAggregator not being ready by features that uses them right away. */
          nonAutoFeatures.forEach(f => {
            if (enabledFeatures[f] && featureNames.includes(f)) {
              (specifier => new Promise(r => r(specifier)).then(s => _interopRequireWildcard(require(s))))("../features/".concat(f, "/aggregate")).then(({
                Aggregate
              }) => {
                this.features[f] = new Aggregate(this);
                this.runtime.harvester.initializedAggregates.push(this.features[f]); // so that harvester will poll this feature agg on interval
              }).catch(err => (0, _console.warn)(25, err));
            }
          });
        });
        return true;
      } catch (err) {
        (0, _console.warn)(26, err);
        return false;
      }
    };
    this.start(nonAutoFeatures.filter(featureName => !!this.init[featureName].autoStart));
  }
  get config() {
    return {
      info: this.info,
      init: this.init,
      loader_config: this.loader_config,
      runtime: this.runtime
    };
  }
  get api() {
    return this;
  }
}
exports.MicroAgent = MicroAgent;