"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setupInteractionAPI = setupInteractionAPI;
var _handle = require("../../common/event-emitter/handle");
var _now = require("../../common/timing/now");
var _constants = require("../../features/metrics/constants");
var _features = require("../features/features");
var _constants2 = require("./constants");
var _sharedHandlers = require("./sharedHandlers");
/**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

function setupInteractionAPI(agent) {
  const tracerEE = agent.ee.get('tracer');
  (0, _sharedHandlers.setupAPI)(_constants2.INTERACTION, function (options) {
    return new InteractionHandle().get(typeof options === 'object' ? options : {});
  }, agent);
  function InteractionHandle() {}
  const InteractionApiProto = InteractionHandle.prototype = {
    createTracer: function (name, cb) {
      var contextStore = {};
      var ixn = this;
      var hasCb = typeof cb === 'function';
      (0, _handle.handle)(_constants.SUPPORTABILITY_METRIC_CHANNEL, ['API/createTracer/called'], undefined, _features.FEATURE_NAMES.metrics, agent.ee);
      // Soft navigations won't support Tracer nodes, but this fn should still work the same otherwise (e.g., run the orig cb).
      if (!agent.runSoftNavOverSpa) (0, _handle.handle)(_constants2.spaPrefix + 'tracer', [(0, _now.now)(), name, contextStore], ixn, _features.FEATURE_NAMES.spa, agent.ee);
      return function () {
        tracerEE.emit((hasCb ? '' : 'no-') + 'fn-start', [(0, _now.now)(), ixn, hasCb], contextStore);
        if (hasCb) {
          try {
            return cb.apply(this, arguments);
          } catch (err) {
            const error = typeof err === 'string' ? new Error(err) : err;
            tracerEE.emit('fn-err', [arguments, this, error], contextStore);
            // the error came from outside the agent, so don't swallow
            throw error;
          } finally {
            tracerEE.emit('fn-end', [(0, _now.now)()], contextStore);
          }
        }
      };
    }
  };
  ['actionText', 'setName', 'setAttribute', 'save', 'ignore', 'onEnd', 'getContext', 'end', 'get'].forEach(name => {
    _sharedHandlers.setupAPI.apply(this, [name, function () {
      (0, _handle.handle)(_constants2.spaPrefix + name, [(0, _now.now)(), ...arguments], this, agent.runSoftNavOverSpa ? _features.FEATURE_NAMES.softNav : _features.FEATURE_NAMES.spa, agent.ee);
      return this;
    }, agent, InteractionApiProto]);
  });
  (0, _sharedHandlers.setupAPI)(_constants2.SET_CURRENT_ROUTE_NAME, function () {
    if (agent.runSoftNavOverSpa) (0, _handle.handle)(_constants2.spaPrefix + 'routeName', [performance.now(), ...arguments], undefined, _features.FEATURE_NAMES.softNav, agent.ee);else (0, _handle.handle)(_constants2.prefix + 'routeName', [(0, _now.now)(), ...arguments], this, _features.FEATURE_NAMES.spa, agent.ee);
  }, agent);
}