"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEBSOCKET_TAG = exports.ADD_EVENT_LISTENER_TAG = void 0;
exports.wrapWebSocket = wrapWebSocket;
var _runtime = require("../constants/runtime");
var _now = require("../timing/now");
var _load = require("../window/load");
var _uniqueId = require("../ids/unique-id");
var _nreum = require("../window/nreum");
/**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

const WEBSOCKET_TAG = exports.WEBSOCKET_TAG = 'websocket-';
const ADD_EVENT_LISTENER_TAG = exports.ADD_EVENT_LISTENER_TAG = 'addEventListener';
const wrapped = {};
function wrapWebSocket(sharedEE) {
  if (wrapped[sharedEE.debugId]++) return sharedEE;
  const originals = (0, _nreum.gosNREUMOriginals)().o;
  if (!originals.WS) return sharedEE;
  function reporter(socketId) {
    const createdAt = (0, _now.now)();
    return function (message, ...data) {
      const timestamp = data[0]?.timeStamp || (0, _now.now)();
      const isLoaded = (0, _load.checkState)();
      sharedEE.emit(WEBSOCKET_TAG + message, [timestamp, timestamp - createdAt, isLoaded, socketId, ...data]);
    };
  }
  class WrappedWebSocket extends WebSocket {
    static name = 'WebSocket';
    constructor(...args) {
      super(...args);
      const socketId = (0, _uniqueId.generateRandomHexString)(6);
      this.report = reporter(socketId);
      this.report('new');
      const events = ['message', 'error', 'open', 'close'];
      /** add event listeners */
      events.forEach(evt => {
        this.addEventListener(evt, function (e) {
          this.report(ADD_EVENT_LISTENER_TAG, {
            eventType: evt,
            event: e
          });
        });
      });
    }
    send(...args) {
      this.report('send', ...args);
      try {
        return super.send(...args);
      } catch (err) {
        this.report('send-err', ...args);
        throw err;
      }
    }
  }
  _runtime.globalScope.WebSocket = WrappedWebSocket;
  return sharedEE;
}