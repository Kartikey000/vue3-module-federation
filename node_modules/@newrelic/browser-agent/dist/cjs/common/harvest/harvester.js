"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Harvester = void 0;
exports.send = send;
var _constants = require("../../features/metrics/constants");
var _features = require("../../loaders/features/features");
var _env = require("../constants/env.npm");
var _runtime = require("../constants/runtime");
var _handle = require("../event-emitter/handle");
var _eventListenerOpts = require("../event-listener/event-listener-opts");
var _now = require("../timing/now");
var _eol = require("../unload/eol");
var _cleanUrl = require("../url/clean-url");
var _encode = require("../url/encode");
var _console = require("../util/console");
var _stringify = require("../util/stringify");
var _submitData = require("../util/submit-data");
var _featureFlags = require("../util/feature-flags");
var _globalEvent = require("../dispatch/global-event");
/**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

const RETRY_FAILED = 'Harvester/Retry/Failed/';
const RETRY_SUCCEEDED = 'Harvester/Retry/Succeeded/';
class Harvester {
  #started = false;
  initializedAggregates = [];
  constructor(agentRef) {
    this.agentRef = agentRef;
    (0, _eol.subscribeToEOL)(() => {
      // do one last harvest round or check
      this.initializedAggregates.forEach(aggregateInst => {
        // let all features wrap up things needed to do before ANY harvest in case there's last minute cross-feature data dependencies
        if (typeof aggregateInst.harvestOpts.beforeUnload === 'function') aggregateInst.harvestOpts.beforeUnload();
      });
      this.initializedAggregates.forEach(aggregateInst => this.triggerHarvestFor(aggregateInst, {
        isFinalHarvest: true
      }));
      /* This callback should run in bubble phase, so that that CWV api, like "onLCP", is called before the final harvest so that emitted timings are part of last outgoing. */
    }, false);
  }
  startTimer(harvestInterval = this.agentRef.init.harvest.interval) {
    if (this.#started) return;
    this.#started = true;
    const onHarvestInterval = () => {
      this.initializedAggregates.forEach(aggregateInst => this.triggerHarvestFor(aggregateInst));
      setTimeout(onHarvestInterval, harvestInterval * 1000); // repeat in X seconds
    };
    setTimeout(onHarvestInterval, harvestInterval * 1000);
  }

  /**
   * Given a feature (aggregate), execute a harvest on-demand.
   * @param {object} aggregateInst
   * @param {object} localOpts
   * @returns {boolean} True if 1+ network call was made. Note that this does not mean or guarantee that it was successful (or that all were in the case of more than 1).
   */
  triggerHarvestFor(aggregateInst, localOpts = {}) {
    if (aggregateInst.blocked) return false;
    const submitMethod = (0, _submitData.getSubmitMethod)(localOpts);
    if (!submitMethod) return false;
    const shouldRetryOnFail = !localOpts.isFinalHarvest && submitMethod === _submitData.xhr; // always retry all features harvests except for final
    let dataToSendArr;
    let ranSend = false;
    if (!localOpts.directSend) {
      // primarily used by rum call to bypass makeHarvestPayload by providing payload directly
      dataToSendArr = aggregateInst.makeHarvestPayload(shouldRetryOnFail, localOpts); // be sure the 'this' of makeHarvestPayload is the aggregate w/ access to its harvestOpts
      if (!dataToSendArr) return false; // can be undefined if storage is empty or preharvest checks failed
    } else dataToSendArr = [localOpts.directSend];
    dataToSendArr.forEach(({
      targetApp,
      payload
    }) => {
      if (!payload) return;
      send(this.agentRef, {
        endpoint: _features.FEATURE_TO_ENDPOINT[aggregateInst.featureName],
        targetApp,
        payload,
        localOpts,
        submitMethod,
        cbFinished,
        raw: aggregateInst.harvestOpts.raw,
        featureName: aggregateInst.featureName
      });
      ranSend = true;
    });
    return ranSend;

    /**
     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.
     * @param {Object} result - information regarding the result of the harvest attempt
     */
    function cbFinished(result) {
      if (aggregateInst.harvestOpts.prevAttemptCode) {
        // this means we just retried a harvest that last failed
        (0, _handle.handle)(_constants.SUPPORTABILITY_METRIC_CHANNEL, [(result.retry ? RETRY_FAILED : RETRY_SUCCEEDED) + aggregateInst.harvestOpts.prevAttemptCode], undefined, _features.FEATURE_NAMES.metrics, aggregateInst.ee);
        delete aggregateInst.harvestOpts.prevAttemptCode; // always reset last observation so we don't falsely report again next harvest
        // In case this re-attempt failed again, that'll be handled (re-marked again) next.
      }
      if (result.retry) aggregateInst.harvestOpts.prevAttemptCode = result.status; // earmark this Agg harvest as failed-but-retrying for next harvest trigger so we can capture metrics about retries

      if (localOpts.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt; used by session reset to flush data belonging to prev session
      aggregateInst.postHarvestCleanup(result);
    }
  }
}

/**
 * @typedef {import('./types.js').NetworkSendSpec} NetworkSendSpec
 */
exports.Harvester = Harvester;
const warnings = {};
/**
  * Initiate a harvest call.
  * @param {NetworkSendSpec} param0 Specification for sending data
  * @returns {boolean} True if a network call was made. Note that this does not mean or guarantee that it was successful.
  */
function send(agentRef, {
  endpoint,
  targetApp,
  payload,
  localOpts = {},
  submitMethod,
  cbFinished,
  raw,
  featureName
}) {
  if (!agentRef.info.errorBeacon) return false;
  let {
    body,
    qs
  } = cleanPayload(payload);
  if (Object.keys(body).length === 0 && !localOpts.sendEmptyBody) {
    // if there's no body to send, just run onfinish stuff and return
    if (cbFinished) cbFinished({
      sent: false,
      targetApp
    });
    return false;
  }
  const protocol = agentRef.init.ssl === false ? 'http' : 'https';
  const perceivedBeacon = agentRef.init.proxy.beacon || agentRef.info.errorBeacon;
  const url = raw ? "".concat(protocol, "://").concat(perceivedBeacon, "/").concat(endpoint) : "".concat(protocol, "://").concat(perceivedBeacon).concat(endpoint !== _features.RUM ? '/' + endpoint : '', "/1/").concat(targetApp.licenseKey);
  const baseParams = !raw ? baseQueryString(agentRef, qs, endpoint, targetApp.applicationID) : '';
  let payloadParams = (0, _encode.obj)(qs, agentRef.runtime.maxBytes);
  if (baseParams === '' && payloadParams.startsWith('&')) {
    payloadParams = payloadParams.substring(1);
  }
  const fullUrl = "".concat(url, "?").concat(baseParams).concat(payloadParams);
  const gzip = !!qs?.attributes?.includes('gzip');

  // all gzipped data is already in the correct format and needs no transformation
  // all features going to 'events' endpoint should already be serialized & stringified
  let stringBody = gzip || endpoint === _features.EVENTS ? body : (0, _stringify.stringify)(body);

  // If body is null, undefined, or an empty object or array after stringifying, send an empty string instead.
  if (!stringBody || stringBody.length === 0 || stringBody === '{}' || stringBody === '[]') stringBody = '';

  // Warn--once per endpoint--if the agent tries to send large payloads
  if (endpoint !== _features.BLOBS && stringBody.length > 750000 && (warnings[endpoint] = (warnings[endpoint] || 0) + 1) === 1) (0, _console.warn)(28, endpoint);
  const headers = [{
    key: 'content-type',
    value: 'text/plain'
  }];

  /* Since workers don't support sendBeacon right now, they can only use XHR method.
      Because they still do permit synch XHR, the idea is that at final harvest time (worker is closing),
      we just make a BLOCKING request--trivial impact--with the remaining data as a temp fill-in for sendBeacon.
     Following the removal of img-element method. */
  let result = submitMethod({
    url: fullUrl,
    body: stringBody,
    sync: localOpts.isFinalHarvest && _runtime.isWorkerScope,
    headers
  });
  if (!localOpts.isFinalHarvest && cbFinished) {
    // final harvests don't hold onto buffer data (shouldRetryOnFail is false), so cleanup isn't needed
    if (submitMethod === _submitData.xhr) {
      result.addEventListener('loadend', function () {
        // `this` here in block refers to the XHR object in this scope, do not change the anon function to an arrow function
        // status 0 refers to a local error, such as CORS or network failure, or a blocked request by the browser (e.g. adblocker)
        const cbResult = {
          sent: this.status !== 0,
          status: this.status,
          retry: shouldRetry(this.status),
          fullUrl,
          xhr: this,
          targetApp
        };
        if (localOpts.needResponse) cbResult.responseText = this.responseText;
        cbFinished(cbResult);

        /** temporary audit of consistency of harvest metadata flags */
        if (!shouldRetry(this.status)) trackHarvestMetadata();
      }, (0, _eventListenerOpts.eventListenerOpts)(false));
    } else if (submitMethod === _submitData.xhrFetch) {
      result.then(async function (response) {
        const status = response.status;
        const cbResult = {
          sent: true,
          status,
          retry: shouldRetry(status),
          fullUrl,
          fetchResponse: response,
          targetApp
        };
        if (localOpts.needResponse) cbResult.responseText = await response.text();
        cbFinished(cbResult);
        /** temporary audit of consistency of harvest metadata flags */
        if (!shouldRetry(status)) trackHarvestMetadata();
      });
    }
    function trackHarvestMetadata() {
      try {
        if (featureName === _features.FEATURE_NAMES.jserrors && !body?.err) return;
        const hasReplay = baseParams.includes('hr=1');
        const hasTrace = baseParams.includes('ht=1');
        const hasError = qs?.attributes?.includes('hasError=true');
        (0, _handle.handle)('harvest-metadata', [{
          [featureName]: {
            ...(hasReplay && {
              hasReplay
            }),
            ...(hasTrace && {
              hasTrace
            }),
            ...(hasError && {
              hasError
            })
          }
        }], undefined, _features.FEATURE_NAMES.metrics, agentRef.ee);
      } catch (err) {
        // do nothing
      }
    }
  }
  (0, _globalEvent.dispatchGlobalEvent)({
    agentIdentifier: agentRef.agentIdentifier,
    drained: !!_featureFlags.activatedFeatures?.[agentRef.agentIdentifier],
    type: 'data',
    name: 'harvest',
    feature: featureName,
    data: {
      endpoint,
      headers,
      targetApp,
      payload,
      submitMethod: getSubmitMethodName(),
      raw,
      synchronousXhr: !!(localOpts.isFinalHarvest && _runtime.isWorkerScope)
    }
  });
  return true;
  function shouldRetry(status) {
    switch (status) {
      case 408:
      case 429:
      case 500:
        return true;
    }
    return status >= 502 && status <= 504 || status >= 512 && status <= 530;
  }
  function getSubmitMethodName() {
    if (submitMethod === _submitData.xhr) return 'xhr';
    if (submitMethod === _submitData.xhrFetch) return 'fetch';
    return 'beacon';
  }
}

/**
 * Cleans and returns a payload object containing a body and qs
 * object with key/value pairs. KV pairs where the value is null,
 * undefined, or an empty string are removed to save on transmission
 * size.
 * @param {HarvestPayload} payload Payload to be sent to the endpoint.
 * @returns {HarvestPayload} Cleaned payload payload to be sent to the endpoint.
 */
function cleanPayload(payload = {}) {
  const clean = input => {
    if (typeof Uint8Array !== 'undefined' && input instanceof Uint8Array || Array.isArray(input)) return input;
    if (typeof input === 'string') return input;
    return Object.entries(input || {}).reduce((accumulator, [key, value]) => {
      if (typeof value === 'number' || typeof value === 'string' && value.length > 0 || typeof value === 'object' && Object.keys(value || {}).length > 0) {
        accumulator[key] = value;
      }
      return accumulator;
    }, {});
  };
  return {
    body: clean(payload.body),
    qs: clean(payload.qs)
  };
}

// The stuff that gets sent every time.
function baseQueryString(agentRef, qs, endpoint, applicationID) {
  const ref = agentRef.runtime.obfuscator.obfuscateString((0, _cleanUrl.cleanURL)('' + _runtime.globalScope.location));
  const hr = agentRef.runtime.session?.state.sessionReplayMode === 1 && endpoint !== _features.JSERRORS;
  const ht = agentRef.runtime.session?.state.sessionTraceMode === 1 && ![_features.LOGS, _features.BLOBS].includes(endpoint);
  const qps = ['a=' + applicationID, (0, _encode.param)('sa', agentRef.info.sa ? '' + agentRef.info.sa : ''), (0, _encode.param)('v', _env.VERSION), transactionNameParam(), (0, _encode.param)('ct', agentRef.runtime.customTransaction), '&rst=' + (0, _now.now)(), '&ck=0',
  // ck param DEPRECATED - still expected by backend
  '&s=' + (agentRef.runtime.session?.state.value || '0'),
  // the 0 id encaps all untrackable and default traffic
  (0, _encode.param)('ref', ref), (0, _encode.param)('ptid', agentRef.runtime.ptid ? '' + agentRef.runtime.ptid : '')];
  if (hr) qps.push((0, _encode.param)('hr', '1', qs));
  if (ht) qps.push((0, _encode.param)('ht', '1', qs));
  return qps.join('');

  // Constructs the transaction name param for the beacon URL.
  // Prefers the obfuscated transaction name over the plain text.
  // Falls back to making up a name.
  function transactionNameParam() {
    if (agentRef.info.transactionName) return (0, _encode.param)('to', agentRef.info.transactionName);
    return (0, _encode.param)('t', agentRef.info.tNamePlain || 'Unnamed Transaction');
  }
}