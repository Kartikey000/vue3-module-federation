"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spa = exports.Instrument = void 0;
var _eventListenerOpts = require("../../../common/event-listener/event-listener-opts");
var _instrumentBase = require("../../utils/instrument-base");
var CONSTANTS = _interopRequireWildcard(require("../constants"));
var _runtime = require("../../../common/constants/runtime");
var _now = require("../../../common/timing/now");
var _handle = require("../../../common/event-emitter/handle");
var _wrapJsonp = require("../../../common/wrap/wrap-jsonp");
var _wrapPromise = require("../../../common/wrap/wrap-promise");
var _wrapTimer = require("../../../common/wrap/wrap-timer");
var _wrapXhr = require("../../../common/wrap/wrap-xhr");
var _wrapFetch = require("../../../common/wrap/wrap-fetch");
var _wrapHistory = require("../../../common/wrap/wrap-history");
var _wrapMutation = require("../../../common/wrap/wrap-mutation");
var _interaction = require("../../../loaders/api/interaction");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; } /**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
const {
  FEATURE_NAME,
  START,
  END,
  BODY,
  CB_END,
  JS_TIME,
  FETCH,
  FN_START,
  CB_START,
  FN_END
} = CONSTANTS;

/**
 * @deprecated This feature has been deprecated, in favor of `soft_navigations`, which is in limited preview. Consider using/importing `SoftNavigations` instead. To gain access to the limited preview, please see https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/browser-spa-v2/ for more information. This feature will be removed in a future release.
 */
class Instrument extends _instrumentBase.InstrumentBase {
  static featureName = FEATURE_NAME;
  constructor(agentRef) {
    super(agentRef, FEATURE_NAME);

    /** feature specific APIs */
    (0, _interaction.setupInteractionAPI)(agentRef);
    if (!_runtime.isBrowserScope) return; // SPA not supported outside web env

    try {
      this.removeOnAbort = new AbortController();
    } catch (e) {}
    let depth = 0;
    let startHash;
    const tracerEE = this.ee.get('tracer');
    const jsonpEE = (0, _wrapJsonp.wrapJsonP)(this.ee);
    const promiseEE = (0, _wrapPromise.wrapPromise)(this.ee);
    const timerEE = (0, _wrapTimer.wrapTimer)(this.ee);
    const xhrEE = (0, _wrapXhr.wrapXhr)(this.ee);
    const eventsEE = this.ee.get('events'); // wrapXhr will call wrapEvents
    const fetchEE = (0, _wrapFetch.wrapFetch)(this.ee);
    const historyEE = (0, _wrapHistory.wrapHistory)(this.ee);
    const mutationEE = (0, _wrapMutation.wrapMutation)(this.ee);
    this.ee.on(FN_START, startTimestamp);
    promiseEE.on(CB_START, startTimestamp);
    jsonpEE.on(CB_START, startTimestamp);
    this.ee.on(FN_END, endTimestamp);
    promiseEE.on(CB_END, endTimestamp);
    jsonpEE.on(CB_END, endTimestamp);
    this.ee.on('fn-err', (...args) => {
      if (!args[2]?.__newrelic?.[agentRef.agentIdentifier]) (0, _handle.handle)('function-err', [...args], undefined, this.featureName, this.ee);
    });
    this.ee.buffer([FN_START, FN_END, 'xhr-resolved'], this.featureName);
    eventsEE.buffer([FN_START], this.featureName);
    timerEE.buffer(['setTimeout' + END, 'clearTimeout' + START, FN_START], this.featureName);
    xhrEE.buffer([FN_START, 'new-xhr', 'send-xhr' + START], this.featureName);
    fetchEE.buffer([FETCH + START, FETCH + '-done', FETCH + BODY + START, FETCH + BODY + END], this.featureName);
    historyEE.buffer(['newURL'], this.featureName);
    mutationEE.buffer([FN_START], this.featureName);
    promiseEE.buffer(['propagate', CB_START, CB_END, 'executor-err', 'resolve' + START], this.featureName);
    tracerEE.buffer([FN_START, 'no-' + FN_START], this.featureName);
    jsonpEE.buffer(['new-jsonp', 'cb-start', 'jsonp-error', 'jsonp-end'], this.featureName);
    timestamp(fetchEE, FETCH + START);
    timestamp(fetchEE, FETCH + '-done');
    timestamp(jsonpEE, 'new-jsonp');
    timestamp(jsonpEE, 'jsonp-end');
    timestamp(jsonpEE, 'cb-start');
    historyEE.on('pushState-end', trackURLChange);
    historyEE.on('replaceState-end', trackURLChange);
    window.addEventListener('hashchange', trackURLChange, (0, _eventListenerOpts.eventListenerOpts)(true, this.removeOnAbort?.signal));
    window.addEventListener('load', trackURLChange, (0, _eventListenerOpts.eventListenerOpts)(true, this.removeOnAbort?.signal));
    window.addEventListener('popstate', function () {
      trackURLChange(0, depth > 1);
    }, (0, _eventListenerOpts.eventListenerOpts)(true, this.removeOnAbort?.signal));
    function trackURLChange(unusedArgs, hashChangedDuringCb) {
      historyEE.emit('newURL', ['' + window.location, hashChangedDuringCb]);
    }
    function startTimestamp() {
      depth++;
      startHash = window.location.hash;
      this[FN_START] = (0, _now.now)();
    }
    function endTimestamp() {
      depth--;
      if (window.location.hash !== startHash) {
        trackURLChange(0, true);
      }
      var time = (0, _now.now)();
      this[JS_TIME] = ~~this[JS_TIME] + time - this[FN_START];
      this[FN_END] = time;
    }
    function timestamp(ee, type) {
      ee.on(type, function () {
        this[type] = (0, _now.now)();
      });
    }
    this.abortHandler = this.#abort;
    this.importAggregator(agentRef, () => Promise.resolve().then(() => _interopRequireWildcard(require(/* webpackChunkName: "spa-aggregate" */'../aggregate'))));
  }

  /** Restoration and resource release tasks to be done if SPA loader is being aborted. Unwind changes to globals and subscription to DOM events. */
  #abort() {
    this.removeOnAbort?.abort();
    this.abortHandler = undefined; // weakly allow this abort op to run only once
  }
}
exports.Instrument = Instrument;
const Spa = exports.Spa = Instrument;