"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SessionReplay = exports.Instrument = void 0;
var _handle = require("../../../common/event-emitter/handle");
var _constants = require("../../../common/session/constants");
var _instrumentBase = require("../../utils/instrument-base");
var _utils = require("../shared/utils");
var _constants2 = require("../constants");
var _recordReplay = require("../../../loaders/api/recordReplay");
var _pauseReplay = require("../../../loaders/api/pauseReplay");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; } /**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */ /**
 * @file Primes the Session Replay feature for lazy loading.
 */
class Instrument extends _instrumentBase.InstrumentBase {
  static featureName = _constants2.FEATURE_NAME;
  /** @type {Promise|undefined} A promise that resolves when the recorder module is imported and added to the class. Undefined if the recorder has never been staged to import with `importRecorder`. */
  #stagedImport;
  /** The RRWEB recorder instance, if imported */
  recorder;
  constructor(agentRef) {
    super(agentRef, _constants2.FEATURE_NAME);

    /** feature specific APIs */
    (0, _recordReplay.setupRecordReplayAPI)(agentRef);
    (0, _pauseReplay.setupPauseReplayAPI)(agentRef);
    let session;
    try {
      session = JSON.parse(localStorage.getItem("".concat(_constants.PREFIX, "_").concat(_constants.DEFAULT_KEY)));
    } catch (err) {}
    if ((0, _utils.hasReplayPrerequisite)(agentRef.init)) {
      this.ee.on(_constants2.SR_EVENT_EMITTER_TYPES.RECORD, () => this.#apiStartOrRestartReplay());
    }
    if (this.#canPreloadRecorder(session)) {
      this.importRecorder().then(recorder => {
        recorder.startRecording(_constants2.TRIGGERS.PRELOAD, session?.sessionReplayMode);
      }); // could handle specific fail-state behaviors with a .catch block here
    }
    this.importAggregator(this.agentRef, () => Promise.resolve().then(() => _interopRequireWildcard(require(/* webpackChunkName: "session_replay-aggregate" */'../aggregate'))), this);

    /** If the recorder is running, we can pass error events on to the agg to help it switch to full mode later */
    this.ee.on('err', e => {
      if (this.blocked) return;
      if (this.agentRef.runtime.isRecording) {
        this.errorNoticed = true;
        (0, _handle.handle)(_constants2.SR_EVENT_EMITTER_TYPES.ERROR_DURING_REPLAY, [e], undefined, this.featureName, this.ee);
      }
    });
  }

  // At this point wherein session state exists already but we haven't init SessionEntity aka verify timers.
  #canPreloadRecorder(session) {
    if (!session) {
      // this might be a new session if entity initializes: conservatively start recording if first-time config allows
      // Note: users with SR enabled, as well as these other configs enabled by-default, will be penalized by the recorder overhead EVEN IF they don't actually have or get
      // entitlement or sampling decision, or otherwise intentionally opted-in for the feature.
      return (0, _utils.isPreloadAllowed)(this.agentRef.init);
    } else if (session.sessionReplayMode === _constants.MODE.FULL || session.sessionReplayMode === _constants.MODE.ERROR) {
      return true; // existing sessions get to continue recording, regardless of this page's configs or if it has expired (conservatively)
    } else {
      // SR mode was OFF but may potentially be turned on if session resets and configs allows the new session to have replay...
      return (0, _utils.isPreloadAllowed)(this.agentRef.init);
    }
  }

  /**
   * Returns a promise that imports the recorder module. Only lets the recorder module be imported and instantiated once. Rejects if failed to import/instantiate.
   * @returns {Promise}
   */
  importRecorder() {
    /** if we already have a recorder fully set up, just return it */
    if (this.recorder) return Promise.resolve(this.recorder);
    /** conditional -- if we have never started importing, stage the import and store it in state */
    this.#stagedImport ??= Promise.resolve().then(() => _interopRequireWildcard(require(/* webpackChunkName: "recorder" */'../shared/recorder'))).then(({
      Recorder
    }) => {
      this.recorder = new Recorder(this);
      /** return the recorder for promise chaining */
      return this.recorder;
    }).catch(err => {
      this.ee.emit('internal-error', [err]);
      this.blocked = true;
      /** return the err for promise chaining */
      throw err;
    });
    return this.#stagedImport;
  }

  /**
   * Called whenever startReplay API is used. That could occur any time, pre or post load.
   */
  #apiStartOrRestartReplay() {
    if (this.blocked) return;
    if (this.featAggregate) {
      // post-load; there's possibly already an ongoing recording
      if (this.featAggregate.mode !== _constants.MODE.FULL) this.featAggregate.initializeRecording(_constants.MODE.FULL, true, _constants2.TRIGGERS.API);
    } else {
      this.importRecorder().then(() => {
        this.recorder.startRecording(_constants2.TRIGGERS.API, _constants.MODE.FULL);
      }); // could handle specific fail-state behaviors with a .catch block here
    }
  }
}
exports.Instrument = Instrument;
const SessionReplay = exports.SessionReplay = Instrument;