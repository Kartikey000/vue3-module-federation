"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SoftNav = exports.Instrument = void 0;
var _nreum = require("../../../common/window/nreum");
var _runtime = require("../../../common/constants/runtime");
var _handle = require("../../../common/event-emitter/handle");
var _eventListenerOpts = require("../../../common/event-listener/event-listener-opts");
var _invoke = require("../../../common/util/invoke");
var _wrapHistory = require("../../../common/wrap/wrap-history");
var _instrumentBase = require("../../utils/instrument-base");
var _constants = require("../constants");
var _now = require("../../../common/timing/now");
var _interaction = require("../../../loaders/api/interaction");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; } /**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The minimal time after a UI event for which no further events will be processed - i.e. a throttling rate to reduce spam.
 * This also give some time for the new interaction to complete without being discarded by a subsequent UI event and wrongly attributed.
 * This value is still subject to change and critique, as it is derived from beyond worst case time to next frame of a page.
 */
const UI_WAIT_INTERVAL = 1 / 10 * 1000; // assume 10 fps

class Instrument extends _instrumentBase.InstrumentBase {
  static featureName = _constants.FEATURE_NAME;
  constructor(agentRef) {
    super(agentRef, _constants.FEATURE_NAME);

    /** feature specific APIs */
    (0, _interaction.setupInteractionAPI)(agentRef);
    if (!_runtime.isBrowserScope || !(0, _nreum.gosNREUMOriginals)().o.MO) return; // soft navigations is not supported outside web env or browsers without the mutation observer API

    const historyEE = (0, _wrapHistory.wrapHistory)(this.ee);
    try {
      this.removeOnAbort = new AbortController();
    } catch (e) {}
    _constants.INTERACTION_TRIGGERS.forEach(trigger => {
      (0, _eventListenerOpts.windowAddEventListener)(trigger, evt => {
        processUserInteraction(evt);
      }, true, this.removeOnAbort?.signal);
    });
    const trackURLChange = () => (0, _handle.handle)('newURL', [(0, _now.now)(), '' + window.location], undefined, this.featureName, this.ee);
    historyEE.on('pushState-end', trackURLChange);
    historyEE.on('replaceState-end', trackURLChange);
    (0, _eventListenerOpts.windowAddEventListener)(_constants.POPSTATE_TRIGGER, evt => {
      // popstate is unique in that it serves as BOTH a UI event and a notification of URL change
      processUserInteraction(evt);
      (0, _handle.handle)('newURL', [evt.timeStamp, '' + window.location], undefined, this.featureName, this.ee);
    }, true, this.removeOnAbort?.signal);
    let oncePerFrame = false; // attempt to reduce dom noice since the observer runs very frequently with below options
    const domObserver = new ((0, _nreum.gosNREUMOriginals)().o.MO)((domChanges, observer) => {
      if (oncePerFrame) return;
      oncePerFrame = true;
      requestAnimationFrame(() => {
        // waiting for next frame to time when any visuals are supposedly updated
        (0, _handle.handle)('newDom', [(0, _now.now)()], undefined, this.featureName, this.ee);
        oncePerFrame = false;
      });
    });
    const processUserInteraction = (0, _invoke.debounce)(event => {
      (0, _handle.handle)('newUIEvent', [event], undefined, this.featureName, this.ee);
      domObserver.observe(document.body, {
        attributes: true,
        childList: true,
        subtree: true,
        characterData: true
      });
    }, UI_WAIT_INTERVAL, {
      leading: true
    });
    this.abortHandler = abort;
    this.importAggregator(agentRef, () => Promise.resolve().then(() => _interopRequireWildcard(require(/* webpackChunkName: "soft_navigations-aggregate" */'../aggregate'))), {
      domObserver
    });
    function abort() {
      this.removeOnAbort?.abort();
      domObserver.disconnect();
      this.abortHandler = undefined; // weakly allow this abort op to run only once
    }
  }
}
exports.Instrument = Instrument;
const SoftNav = exports.SoftNav = Instrument;