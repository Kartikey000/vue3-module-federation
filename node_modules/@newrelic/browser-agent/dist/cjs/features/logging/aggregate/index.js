"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Aggregate = void 0;
var _registerHandler = require("../../../common/event-emitter/register-handler");
var _console = require("../../../common/util/console");
var _stringify = require("../../../common/util/stringify");
var _aggregateBase = require("../../utils/aggregate-base");
var _constants = require("../constants");
var _log = require("../shared/log");
var _utils = require("../shared/utils");
var _traverse = require("../../../common/util/traverse");
var _target = require("../../../common/util/target");
var _constants2 = require("../../../common/session/constants");
var _constants3 = require("../../session_replay/constants");
var _featureGates = require("../../utils/feature-gates");
/**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

class Aggregate extends _aggregateBase.AggregateBase {
  static featureName = _constants.FEATURE_NAME;
  constructor(agentRef) {
    super(agentRef, _constants.FEATURE_NAME);
    this.isSessionTrackingEnabled = (0, _featureGates.canEnableSessionTracking)(agentRef.init) && agentRef.runtime.session;
    super.customAttributesAreSeparate = true;

    // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.
    this.ee.on(_constants2.SESSION_EVENTS.RESET, () => {
      this.abort(_constants3.ABORT_REASONS.RESET);
    });
    this.ee.on(_constants2.SESSION_EVENTS.UPDATE, (type, data) => {
      if (this.blocked || type !== _constants2.SESSION_EVENT_TYPES.CROSS_TAB) return;
      if (this.loggingMode !== _constants.LOGGING_MODE.OFF && data.loggingMode === _constants.LOGGING_MODE.OFF) this.abort(_constants3.ABORT_REASONS.CROSS_TAB);else this.loggingMode = data.loggingMode;
    });
    this.harvestOpts.raw = true;
    this.waitForFlags(['log']).then(([loggingMode]) => {
      const session = this.agentRef.runtime.session ?? {};
      if (this.loggingMode === _constants.LOGGING_MODE.OFF || session.isNew && loggingMode === _constants.LOGGING_MODE.OFF) {
        this.blocked = true;
        this.deregisterDrain();
        return;
      }
      if (session.isNew || !this.isSessionTrackingEnabled) {
        this.updateLoggingMode(loggingMode);
      } else {
        this.loggingMode = session.state.loggingMode;
      }

      /** emitted by instrument class (wrapped loggers) or the api methods directly */
      (0, _registerHandler.registerHandler)(_constants.LOGGING_EVENT_EMITTER_CHANNEL, this.handleLog.bind(this), this.featureName, this.ee);
      this.drain();
      /** harvest immediately once started to purge pre-load logs collected */
      agentRef.runtime.harvester.triggerHarvestFor(this);
    });
  }
  updateLoggingMode(loggingMode) {
    this.loggingMode = loggingMode;
    this.syncWithSessionManager({
      loggingMode: this.loggingMode
    });
  }
  handleLog(timestamp, message, attributes = {}, level = _constants.LOG_LEVELS.INFO, targetEntityGuid) {
    if (!this.agentRef.runtime.entityManager.get(targetEntityGuid)) return (0, _console.warn)(56, this.featureName);
    if (this.blocked || !this.loggingMode) return;
    if (!attributes || typeof attributes !== 'object') attributes = {};
    if (typeof level === 'string') level = level.toUpperCase();
    if (!(0, _utils.isValidLogLevel)(level)) return (0, _console.warn)(30, level);
    if (this.loggingMode < (_constants.LOGGING_MODE[level] || Infinity)) {
      this.reportSupportabilityMetric('Logging/Event/Dropped/Sampling');
      return;
    }
    try {
      if (typeof message !== 'string') {
        const stringified = (0, _stringify.stringify)(message);
        /**
           * Error instances convert to `{}` when stringified
           * Symbol converts to '' when stringified
           * other cases tbd
           * */
        if (!!stringified && stringified !== '{}') message = stringified;else message = String(message);
      }
    } catch (err) {
      (0, _console.warn)(16, message);
      this.reportSupportabilityMetric('Logging/Event/Dropped/Casting');
      return;
    }
    if (typeof message !== 'string' || !message) return (0, _console.warn)(32);
    const log = new _log.Log(Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(timestamp)), message, attributes, level);
    this.events.add(log, targetEntityGuid);
  }
  serializer(eventBuffer, targetEntityGuid) {
    const target = this.agentRef.runtime.entityManager.get(targetEntityGuid);
    const sessionEntity = this.agentRef.runtime.session;
    return [{
      common: {
        /** Attributes in the `common` section are added to `all` logs generated in the payload */
        attributes: {
          'entity.guid': target.entityGuid,
          // browser entity guid as provided API target OR the default from RUM response if not supplied
          ...(sessionEntity && {
            session: sessionEntity.state.value || '0',
            // The session ID that we generate and keep across page loads
            hasReplay: sessionEntity.state.sessionReplayMode === 1 && (0, _target.isContainerAgentTarget)(target, this.agentRef),
            // True if a session replay recording is running
            hasTrace: sessionEntity.state.sessionTraceMode === 1 // True if a session trace recording is running
          }),
          ptid: this.agentRef.runtime.ptid,
          // page trace id
          appId: target.applicationID || this.agentRef.info.applicationID,
          // Application ID from info object,
          standalone: Boolean(this.agentRef.info.sa),
          // copy paste (true) vs APM (false)
          agentVersion: this.agentRef.runtime.version,
          // browser agent version
          // The following 3 attributes are evaluated and dropped at ingest processing time and do not get stored on NRDB:
          'instrumentation.provider': 'browser',
          'instrumentation.version': this.agentRef.runtime.version,
          'instrumentation.name': this.agentRef.runtime.loaderType,
          // Custom attributes
          ...this.agentRef.info.jsAttributes
        }
      },
      /** logs section contains individual unique log entries */
      logs: (0, _traverse.applyFnToProps)(eventBuffer, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string')
    }];
  }
  queryStringsBuilder(_, targetEntityGuid) {
    const target = this.agentRef.runtime.entityManager.get(targetEntityGuid);
    return {
      browser_monitoring_key: target.licenseKey
    };
  }

  /** Abort the feature, once aborted it will not resume */
  abort(reason = {}) {
    this.reportSupportabilityMetric("Logging/Abort/".concat(reason.sm));
    this.blocked = true;
    if (this.events) {
      this.events.clear();
      this.events.clearSave();
    }
    this.updateLoggingMode(_constants.LOGGING_MODE.OFF);
    this.deregisterDrain();
  }
  syncWithSessionManager(state = {}) {
    if (this.isSessionTrackingEnabled) {
      this.agentRef.runtime.session.write(state);
    }
  }
}
exports.Aggregate = Aggregate;