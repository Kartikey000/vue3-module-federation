"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Aggregate = void 0;
var _stringify = require("../../../common/util/stringify");
var _cleanUrl = require("../../../common/url/clean-url");
var _constants = require("../constants");
var _runtime = require("../../../common/constants/runtime");
var _aggregateBase = require("../../utils/aggregate-base");
var _console = require("../../../common/util/console");
var _now = require("../../../common/timing/now");
var _registerHandler = require("../../../common/event-emitter/register-handler");
var _traverse = require("../../../common/util/traverse");
var _userActionsAggregator = require("./user-actions/user-actions-aggregator");
var _iframe = require("../../../common/dom/iframe");
var _typeCheck = require("../../../common/util/type-check");
/**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

class Aggregate extends _aggregateBase.AggregateBase {
  static featureName = _constants.FEATURE_NAME;
  #userActionAggregator;
  constructor(agentRef) {
    super(agentRef, _constants.FEATURE_NAME);
    this.referrerUrl = _runtime.isBrowserScope && document.referrer ? (0, _cleanUrl.cleanURL)(document.referrer) : undefined;
    this.waitForFlags(['ins']).then(([ins]) => {
      if (!ins) {
        this.blocked = true;
        this.deregisterDrain();
        return;
      }
      this.#trackSupportabilityMetrics();
      (0, _registerHandler.registerHandler)('api-recordCustomEvent', (timestamp, eventType, attributes) => {
        if (_constants.RESERVED_EVENT_TYPES.includes(eventType)) return (0, _console.warn)(46);
        this.addEvent({
          eventType,
          timestamp: this.toEpoch(timestamp),
          ...attributes
        });
      }, this.featureName, this.ee);
      if (agentRef.init.page_action.enabled) {
        (0, _registerHandler.registerHandler)('api-addPageAction', (timestamp, name, attributes, targetEntityGuid) => {
          if (!this.agentRef.runtime.entityManager.get(targetEntityGuid)) return (0, _console.warn)(56, this.featureName);
          this.addEvent({
            ...attributes,
            eventType: 'PageAction',
            timestamp: this.toEpoch(timestamp),
            timeSinceLoad: timestamp / 1000,
            actionName: name,
            referrerUrl: this.referrerUrl,
            ...(_runtime.isBrowserScope && {
              browserWidth: window.document.documentElement?.clientWidth,
              browserHeight: window.document.documentElement?.clientHeight
            })
          }, targetEntityGuid);
        }, this.featureName, this.ee);
      }
      let addUserAction = () => {/** no-op */};
      if (_runtime.isBrowserScope && agentRef.init.user_actions.enabled) {
        this.#userActionAggregator = new _userActionsAggregator.UserActionsAggregator(agentRef.init.feature_flags.includes('user_frustrations'));
        this.harvestOpts.beforeUnload = () => addUserAction?.(this.#userActionAggregator.aggregationEvent);
        addUserAction = aggregatedUserAction => {
          try {
            /** The aggregator process only returns an event when it is "done" aggregating -
             * so we still need to validate that an event was given to this method before we try to add */
            if (aggregatedUserAction?.event) {
              const {
                target,
                timeStamp,
                type
              } = aggregatedUserAction.event;
              const userActionEvent = {
                eventType: 'UserAction',
                timestamp: this.toEpoch(timeStamp),
                action: type,
                actionCount: aggregatedUserAction.count,
                actionDuration: aggregatedUserAction.relativeMs[aggregatedUserAction.relativeMs.length - 1],
                actionMs: aggregatedUserAction.relativeMs,
                rageClick: aggregatedUserAction.rageClick,
                target: aggregatedUserAction.selectorPath,
                currentUrl: aggregatedUserAction.currentUrl,
                ...((0, _iframe.isIFrameWindow)(window) && {
                  iframe: true
                }),
                ...this.agentRef.init.user_actions.elementAttributes.reduce((acc, field) => {
                  /** prevent us from capturing an obscenely long value */
                  if (canTrustTargetAttribute(field)) acc[targetAttrName(field)] = String(target[field]).trim().slice(0, 128);
                  return acc;
                }, {}),
                ...aggregatedUserAction.nearestTargetFields,
                ...(aggregatedUserAction.deadClick && {
                  deadClick: true
                }),
                ...(aggregatedUserAction.errorClick && {
                  errorClick: true
                })
              };
              this.addEvent(userActionEvent);
              this.#trackUserActionSM(userActionEvent);

              /**
               * Returns the original target field name with `target` prepended and camelCased
               * @param {string} originalFieldName
               * @returns {string} the target field name
               */
              function targetAttrName(originalFieldName) {
                /** preserve original renaming structure for pre-existing field maps */
                if (originalFieldName === 'tagName') originalFieldName = 'tag';
                if (originalFieldName === 'className') originalFieldName = 'class';
                /** return the original field name, cap'd and prepended with target to match formatting */
                return "target".concat(originalFieldName.charAt(0).toUpperCase() + originalFieldName.slice(1));
              }

              /**
               * Only trust attributes that exist on HTML element targets, which excludes the window and the document targets
               * @param {string} attribute The attribute to check for on the target element
               * @returns {boolean} Whether the target element has the attribute and can be trusted
               */
              function canTrustTargetAttribute(attribute) {
                return !!(aggregatedUserAction.selectorPath !== 'window' && aggregatedUserAction.selectorPath !== 'document' && target instanceof HTMLElement && target?.[attribute]);
              }
            }
          } catch (e) {
            // do nothing for now
          }
        };
        (0, _registerHandler.registerHandler)('ua', evt => {
          /** the processor will return the previously aggregated event if it has been completed by processing the current event */
          addUserAction(this.#userActionAggregator.process(evt, this.agentRef.init.user_actions.elementAttributes));
        }, this.featureName, this.ee);
        (0, _registerHandler.registerHandler)('navChange', () => {
          this.#userActionAggregator.isLiveClick();
        }, this.featureName, this.ee);
        (0, _registerHandler.registerHandler)('uaXhr', () => {
          this.#userActionAggregator.isLiveClick();
        }, this.featureName, this.ee);
        (0, _registerHandler.registerHandler)('uaErr', () => this.#userActionAggregator.markAsErrorClick(), this.featureName, this.ee);
      }

      /**
       * is it worth complicating the agent and skipping the POs for single repeating queries? maybe,
       * but right now it was less desirable simply because it is a nice benefit of populating the event buffer
       * immediately as events happen for payload evaluation purposes and that becomes a little more chaotic
       * with an arbitrary query method. note: eventTypes: [...types] does not support the 'buffered' flag so we have
       * to create up to two PO's here.
       */
      const performanceTypesToCapture = [...(agentRef.init.performance.capture_marks ? ['mark'] : []), ...(agentRef.init.performance.capture_measures ? ['measure'] : [])];
      if (performanceTypesToCapture.length) {
        try {
          performanceTypesToCapture.forEach(type => {
            if (PerformanceObserver.supportedEntryTypes.includes(type)) {
              const observer = new PerformanceObserver(list => {
                list.getEntries().forEach(entry => {
                  try {
                    this.reportSupportabilityMetric('Generic/Performance/' + type + '/Seen');
                    const detailObj = agentRef.init.performance.capture_detail ? createDetailAttrs(entry.detail) : {};
                    this.addEvent({
                      ...detailObj,
                      eventType: 'BrowserPerformance',
                      timestamp: this.toEpoch(entry.startTime),
                      entryName: entry.name,
                      entryDuration: entry.duration,
                      entryType: type
                    });
                    function createDetailAttrs(detail) {
                      if (detail === null || detail === undefined) return {};else if (!(0, _typeCheck.isPureObject)(detail)) return {
                        entryDetail: detail
                      };else return flattenJSON(detail);
                      function flattenJSON(nestedJSON, parentKey = 'entryDetail') {
                        let items = {};
                        if (nestedJSON === null || nestedJSON === undefined) return items;
                        Object.keys(nestedJSON).forEach(key => {
                          let newKey = parentKey + '.' + key;
                          if ((0, _typeCheck.isPureObject)(nestedJSON[key])) {
                            Object.assign(items, flattenJSON(nestedJSON[key], newKey));
                          } else {
                            if (nestedJSON[key] !== null && nestedJSON[key] !== undefined) items[newKey] = nestedJSON[key];
                          }
                        });
                        return items;
                      }
                    }
                  } catch (err) {}
                });
              });
              observer.observe({
                buffered: true,
                type
              });
            }
          });
        } catch (err) {
          // Something failed in our set up, likely the browser does not support PO's... do nothing
        }
      }
      if (_runtime.isBrowserScope && agentRef.init.performance.resources.enabled) {
        (0, _registerHandler.registerHandler)('browserPerformance.resource', entry => {
          try {
            // convert the entry to a plain object and separate the name and duration from the object
            // you need to do this to be able to spread it into the addEvent call later, and name and duration
            // would be duplicative of entryName and entryDuration and are protected keys in NR1
            const {
              name,
              duration,
              ...entryObject
            } = entry.toJSON();
            let firstParty = false;
            try {
              const entryDomain = new URL(name).hostname;
              const isNr = entryDomain.includes('newrelic.com') || entryDomain.includes('nr-data.net') || entryDomain.includes('nr-local.net');
              /** decide if we should ignore nr-specific assets */
              if (this.agentRef.init.performance.resources.ignore_newrelic && isNr) return;
              /** decide if we should ignore the asset type (empty means allow everything, which is the default) */
              if (this.agentRef.init.performance.resources.asset_types.length && !this.agentRef.init.performance.resources.asset_types.includes(entryObject.initiatorType)) return;
              /** decide if the entryDomain is a first party domain */
              firstParty = entryDomain === _runtime.globalScope?.location.hostname || agentRef.init.performance.resources.first_party_domains.includes(entryDomain);
              if (firstParty) this.reportSupportabilityMetric('Generic/Performance/FirstPartyResource/Seen');
              if (isNr) this.reportSupportabilityMetric('Generic/Performance/NrResource/Seen');
            } catch (err) {
              // couldnt parse the URL, so firstParty will just default to false
            }
            this.reportSupportabilityMetric('Generic/Performance/Resource/Seen');
            const event = {
              ...entryObject,
              eventType: 'BrowserPerformance',
              timestamp: Math.floor(agentRef.runtime.timeKeeper.correctRelativeTimestamp(entryObject.startTime)),
              entryName: (0, _cleanUrl.cleanURL)(name),
              entryDuration: duration,
              firstParty
            };
            this.addEvent(event);
          } catch (err) {
            this.ee.emit('internal-error', [err, 'GenericEvents-Resource']);
          }
        }, this.featureName, this.ee);
      }
      (0, _registerHandler.registerHandler)('api-measure', (args, n) => {
        const {
          start,
          duration,
          customAttributes
        } = args;
        const event = {
          ...customAttributes,
          eventType: 'BrowserPerformance',
          timestamp: Math.floor(agentRef.runtime.timeKeeper.correctRelativeTimestamp(start)),
          entryName: n,
          entryDuration: duration,
          entryType: 'measure'
        };
        this.addEvent(event);
      }, this.featureName, this.ee);
      agentRef.runtime.harvester.triggerHarvestFor(this);
      this.drain();
    });
  }

  // WARNING: Insights times are in seconds. EXCEPT timestamp, which is in ms.
  /** Some keys are set by the query params or request headers sent with the harvest and override the body values, so check those before adding new standard body values...
   * see harvest.js#baseQueryString for more info on the query params
   * Notably:
   * * name: set by the `t=` query param
   * * appId: set by the `a=` query param
   * * standalone: set by the `sa=` query param
   * * session: set by the `s=` query param
   * * sessionTraceId: set by the `ptid=` query param
   * * userAgent*: set by the userAgent header
   * @param {object=} obj the event object for storing in the event buffer
   * @param {string=} targetEntityGuid the target entity guid for the event to scope buffering and harvesting. Defaults to agent config if undefined
   * @returns void
   */
  addEvent(obj = {}, targetEntityGuid) {
    if (!obj || !Object.keys(obj).length) return;
    if (!obj.eventType) {
      (0, _console.warn)(44);
      return;
    }
    for (let key in obj) {
      let val = obj[key];
      obj[key] = val && typeof val === 'object' ? (0, _stringify.stringify)(val) : val;
    }
    const defaultEventAttributes = {
      /** should be overridden by the event-specific attributes, but just in case -- set it to now() */
      timestamp: Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp((0, _now.now)())),
      /** all generic events require pageUrl(s) */
      pageUrl: (0, _cleanUrl.cleanURL)('' + _runtime.initialLocation),
      currentUrl: (0, _cleanUrl.cleanURL)('' + location)
    };
    const eventAttributes = {
      /** Agent-level custom attributes */
      ...(this.agentRef.info.jsAttributes || {}),
      /** Fallbacks for required properties in-case the event did not supply them, should take precedence over agent-level custom attrs */
      ...defaultEventAttributes,
      /** Event-specific attributes take precedence over agent-level custom attributes and fallbacks */
      ...obj
    };
    this.events.add(eventAttributes, targetEntityGuid);
  }
  serializer(eventBuffer) {
    return (0, _traverse.applyFnToProps)({
      ins: eventBuffer
    }, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string');
  }
  queryStringsBuilder() {
    return {
      ua: this.agentRef.info.userAttributes,
      at: this.agentRef.info.atts
    };
  }
  toEpoch(timestamp) {
    return Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(timestamp));
  }
  #trackSupportabilityMetrics() {
    /** track usage SMs to improve these experimental features */
    const configPerfTag = 'Config/Performance/';
    if (this.agentRef.init.performance.capture_marks) this.reportSupportabilityMetric(configPerfTag + 'CaptureMarks/Enabled');
    if (this.agentRef.init.performance.capture_measures) this.reportSupportabilityMetric(configPerfTag + 'CaptureMeasures/Enabled');
    if (this.agentRef.init.performance.resources.enabled) this.reportSupportabilityMetric(configPerfTag + 'Resources/Enabled');
    if (this.agentRef.init.performance.resources.asset_types?.length !== 0) this.reportSupportabilityMetric(configPerfTag + 'Resources/AssetTypes/Changed');
    if (this.agentRef.init.performance.resources.first_party_domains?.length !== 0) this.reportSupportabilityMetric(configPerfTag + 'Resources/FirstPartyDomains/Changed');
    if (this.agentRef.init.performance.resources.ignore_newrelic === false) this.reportSupportabilityMetric(configPerfTag + 'Resources/IgnoreNewrelic/Changed');
  }
  #trackUserActionSM(ua) {
    if (ua.rageClick) this.reportSupportabilityMetric('UserAction/RageClick/Seen');
    if (ua.deadClick) this.reportSupportabilityMetric('UserAction/DeadClick/Seen');
    if (ua.errorClick) this.reportSupportabilityMetric('UserAction/ErrorClick/Seen');
  }
}
exports.Aggregate = Aggregate;