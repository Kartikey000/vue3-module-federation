"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Instrument = exports.GenericEvents = void 0;
var _runtime = require("../../../common/constants/runtime");
var _handle = require("../../../common/event-emitter/handle");
var _eventListenerOpts = require("../../../common/event-listener/event-listener-opts");
var _invoke = require("../../../common/util/invoke");
var _addPageAction = require("../../../loaders/api/addPageAction");
var _finished = require("../../../loaders/api/finished");
var _recordCustomEvent = require("../../../loaders/api/recordCustomEvent");
var _register = require("../../../loaders/api/register");
var _measure = require("../../../loaders/api/measure");
var _instrumentBase = require("../../utils/instrument-base");
var _constants = require("../constants");
var _features = require("../../../loaders/features/features");
var _wrapHistory = require("../../../common/wrap/wrap-history");
var _wrapFetch = require("../../../common/wrap/wrap-fetch");
var _wrapXhr = require("../../../common/wrap/wrap-xhr");
var _parseUrl = require("../../../common/url/parse-url");
var _extractUrl = require("../../../common/url/extract-url");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; } /**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
class Instrument extends _instrumentBase.InstrumentBase {
  static featureName = _constants.FEATURE_NAME;
  constructor(agentRef) {
    super(agentRef, _constants.FEATURE_NAME);
    /** config values that gate whether the generic events aggregator should be imported at all */
    const genericEventSourceConfigs = [agentRef.init.page_action.enabled, agentRef.init.performance.capture_marks, agentRef.init.performance.capture_measures, agentRef.init.user_actions.enabled, agentRef.init.performance.resources.enabled];

    /** feature specific APIs */
    (0, _addPageAction.setupAddPageActionAPI)(agentRef);
    (0, _recordCustomEvent.setupRecordCustomEventAPI)(agentRef);
    (0, _finished.setupFinishedAPI)(agentRef);
    (0, _register.setupRegisterAPI)(agentRef);
    (0, _measure.setupMeasureAPI)(agentRef);
    if (_runtime.isBrowserScope) {
      if (agentRef.init.user_actions.enabled) {
        _constants.OBSERVED_EVENTS.forEach(eventType => (0, _eventListenerOpts.windowAddEventListener)(eventType, evt => (0, _handle.handle)('ua', [evt], undefined, this.featureName, this.ee), true));
        _constants.OBSERVED_WINDOW_EVENTS.forEach(eventType => {
          const debounceHandler = (0, _invoke.debounce)(evt => {
            (0, _handle.handle)('ua', [evt], undefined, this.featureName, this.ee);
          }, 500, {
            leading: true
          });
          (0, _eventListenerOpts.windowAddEventListener)(eventType, debounceHandler);
        }
        // Capture is not used here so that we don't get element focus/blur events, only the window's as they do not bubble. They are also not cancellable, so no worries about being front of line.
        );
      }
      if (agentRef.init.performance.resources.enabled && _runtime.globalScope.PerformanceObserver?.supportedEntryTypes.includes('resource')) {
        const observer = new PerformanceObserver(list => {
          list.getEntries().forEach(entry => {
            (0, _handle.handle)('browserPerformance.resource', [entry], undefined, this.featureName, this.ee);
          });
        });
        observer.observe({
          type: 'resource',
          buffered: true
        });
      }
      const historyEE = (0, _wrapHistory.wrapHistory)(this.ee);
      historyEE.on('pushState-end', navigationChange);
      historyEE.on('replaceState-end', navigationChange);
      window.addEventListener('hashchange', navigationChange, (0, _eventListenerOpts.eventListenerOpts)(true, this.removeOnAbort?.signal));
      window.addEventListener('popstate', navigationChange, (0, _eventListenerOpts.eventListenerOpts)(true, this.removeOnAbort?.signal));
      function navigationChange() {
        historyEE.emit('navChange');
      }
    }
    try {
      this.removeOnAbort = new AbortController();
    } catch (e) {}
    this.abortHandler = () => {
      this.removeOnAbort?.abort();
      this.abortHandler = undefined; // weakly allow this abort op to run only once
    };
    _runtime.globalScope.addEventListener('error', () => {
      (0, _handle.handle)('uaErr', [], undefined, _features.FEATURE_NAMES.genericEvents, this.ee);
    }, (0, _eventListenerOpts.eventListenerOpts)(false, this.removeOnAbort?.signal));
    (0, _wrapFetch.wrapFetch)(this.ee);
    (0, _wrapXhr.wrapXhr)(this.ee);
    this.ee.on('open-xhr-start', (args, xhr) => {
      if (!isInternalTraffic(args[1])) {
        xhr.addEventListener('readystatechange', () => {
          if (xhr.readyState === 2) {
            // HEADERS_RECEIVED
            (0, _handle.handle)('uaXhr', [], undefined, _features.FEATURE_NAMES.genericEvents, this.ee);
          }
        });
      }
    });
    this.ee.on('fetch-start', fetchArguments => {
      if (fetchArguments.length >= 1 && !isInternalTraffic((0, _extractUrl.extractUrl)(fetchArguments[0]))) {
        (0, _handle.handle)('uaXhr', [], undefined, _features.FEATURE_NAMES.genericEvents, this.ee);
      }
    });
    function isInternalTraffic(url) {
      const parsedUrl = (0, _parseUrl.parseUrl)(url);
      return agentRef.beacons.includes(parsedUrl.hostname + ':' + parsedUrl.port);
    }

    /** If any of the sources are active, import the aggregator. otherwise deregister */
    if (genericEventSourceConfigs.some(x => x)) this.importAggregator(agentRef, () => Promise.resolve().then(() => _interopRequireWildcard(require(/* webpackChunkName: "generic_events-aggregate" */'../aggregate'))));else this.deregisterDrain();
  }
}
exports.Instrument = Instrument;
const GenericEvents = exports.GenericEvents = Instrument;