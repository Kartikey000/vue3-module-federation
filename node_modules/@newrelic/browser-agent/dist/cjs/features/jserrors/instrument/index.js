"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JSErrors = exports.Instrument = void 0;
var _handle = require("../../../common/event-emitter/handle");
var _instrumentBase = require("../../utils/instrument-base");
var _constants = require("../constants");
var _runtime = require("../../../common/constants/runtime");
var _eventListenerOpts = require("../../../common/event-listener/event-listener-opts");
var _now = require("../../../common/timing/now");
var _castError = require("../shared/cast-error");
var _noticeError = require("../../../loaders/api/noticeError");
var _setErrorHandler = require("../../../loaders/api/setErrorHandler");
var _addRelease = require("../../../loaders/api/addRelease");
var _register = require("../../../loaders/api/register");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; } /**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
class Instrument extends _instrumentBase.InstrumentBase {
  static featureName = _constants.FEATURE_NAME;
  constructor(agentRef) {
    super(agentRef, _constants.FEATURE_NAME);

    /** feature specific APIs */
    (0, _noticeError.setupNoticeErrorAPI)(agentRef);
    (0, _setErrorHandler.setupSetErrorHandlerAPI)(agentRef);
    (0, _addRelease.setupAddReleaseAPI)(agentRef);
    (0, _register.setupRegisterAPI)(agentRef);
    try {
      // this try-catch can be removed when IE11 is completely unsupported & gone
      this.removeOnAbort = new AbortController();
    } catch (e) {}
    this.ee.on('internal-error', (error, reason) => {
      if (!this.abortHandler) return;
      (0, _handle.handle)('ierr', [(0, _castError.castError)(error), (0, _now.now)(), true, {}, agentRef.runtime.isRecording, reason], undefined, this.featureName, this.ee);
    });
    _runtime.globalScope.addEventListener('unhandledrejection', promiseRejectionEvent => {
      if (!this.abortHandler) return;
      (0, _handle.handle)('err', [(0, _castError.castPromiseRejectionEvent)(promiseRejectionEvent), (0, _now.now)(), false, {
        unhandledPromiseRejection: 1
      }, agentRef.runtime.isRecording], undefined, this.featureName, this.ee);
    }, (0, _eventListenerOpts.eventListenerOpts)(false, this.removeOnAbort?.signal));
    _runtime.globalScope.addEventListener('error', errorEvent => {
      if (!this.abortHandler) return;
      (0, _handle.handle)('err', [(0, _castError.castErrorEvent)(errorEvent), (0, _now.now)(), false, {}, agentRef.runtime.isRecording], undefined, this.featureName, this.ee);
    }, (0, _eventListenerOpts.eventListenerOpts)(false, this.removeOnAbort?.signal));
    this.abortHandler = this.#abort; // we also use this as a flag to denote that the feature is active or on and handling errors
    this.importAggregator(agentRef, () => Promise.resolve().then(() => _interopRequireWildcard(require(/* webpackChunkName: "jserrors-aggregate" */'../aggregate'))));
  }

  /** Restoration and resource release tasks to be done if JS error loader is being aborted. Unwind changes to globals. */
  #abort() {
    this.removeOnAbort?.abort();
    this.abortHandler = undefined; // weakly allow this abort op to run only once
  }
}
exports.Instrument = Instrument;
const JSErrors = exports.JSErrors = Instrument;