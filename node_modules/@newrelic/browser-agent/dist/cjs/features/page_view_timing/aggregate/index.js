"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Aggregate = void 0;
var _belSerializer = require("../../../common/serialize/bel-serializer");
var _registerHandler = require("../../../common/event-emitter/register-handler");
var _handle = require("../../../common/event-emitter/handle");
var _constants = require("../constants");
var _features = require("../../../loaders/features/features");
var _aggregateBase = require("../../utils/aggregate-base");
var _cumulativeLayoutShift = require("../../../common/vitals/cumulative-layout-shift");
var _firstContentfulPaint = require("../../../common/vitals/first-contentful-paint");
var _firstPaint = require("../../../common/vitals/first-paint");
var _interactionToNextPaint = require("../../../common/vitals/interaction-to-next-paint");
var _largestContentfulPaint = require("../../../common/vitals/largest-contentful-paint");
var _timeToFirstByte = require("../../../common/vitals/time-to-first-byte");
var _pageVisibility = require("../../../common/window/page-visibility");
var _constants2 = require("../../../common/vitals/constants");
var _runtime = require("../../../common/constants/runtime");
var _eventOrigin = require("../../../common/util/event-origin");
/**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

class Aggregate extends _aggregateBase.AggregateBase {
  static featureName = _constants.FEATURE_NAME;
  #handleVitalMetric = ({
    name,
    value,
    attrs
  }) => {
    this.addTiming(name, value, attrs);
  };
  constructor(agentRef) {
    super(agentRef, _constants.FEATURE_NAME);
    this.curSessEndRecorded = false;
    this.firstIxnRecorded = false;
    super.customAttributesAreSeparate = true;
    (0, _registerHandler.registerHandler)('docHidden', msTimestamp => this.endCurrentSession(msTimestamp), this.featureName, this.ee);
    // Add the time of _window pagehide event_ firing to the next PVT harvest == NRDB windowUnload attr:
    (0, _registerHandler.registerHandler)('winPagehide', msTimestamp => this.addTiming('unload', msTimestamp, null), this.featureName, this.ee);
    this.waitForFlags([]).then(() => {
      _firstPaint.firstPaint.subscribe(this.#handleVitalMetric);
      _firstContentfulPaint.firstContentfulPaint.subscribe(this.#handleVitalMetric);
      _largestContentfulPaint.largestContentfulPaint.subscribe(this.#handleVitalMetric);
      _interactionToNextPaint.interactionToNextPaint.subscribe(this.#handleVitalMetric);
      _timeToFirstByte.timeToFirstByte.subscribe(({
        attrs
      }) => {
        this.addTiming('load', Math.round(attrs.navigationEntry.loadEventEnd));
      });
      (0, _pageVisibility.subscribeToVisibilityChange)(() => {
        /* Downstream, the event consumer interprets all timing node value as ms-unit and converts it to seconds via division by 1000. CLS is unitless so this normally is a problem.
          bel.6 schema also doesn't support decimal values, of which cls within [0,1). However, the two nicely cancels out, and we can multiply cls by 1000 to both negate the division
          and send an integer > 1. We effectively lose some precision down to 3 decimal places for this workaround. E.g. (real) 0.749132... -> 749.132...-> 749 -> 0.749 (final) */
        const {
          name,
          value,
          attrs
        } = _cumulativeLayoutShift.cumulativeLayoutShift.current;
        if (value === undefined) return;
        this.addTiming(name, value * 1000, attrs);
      }, true, true); // CLS node should only reports on vis change rather than on every change

      this.drain();
    });
  }

  /**
   * Add the time of _document visibilitychange to hidden_ to the next PVT harvest == NRDB pageHide attr.
   * @param {number} timestamp
   */
  endCurrentSession(timestamp) {
    if (!this.curSessEndRecorded) {
      // TO DO: stage 2 - we don't want to capture this timing twice on page navigating away, but it should run again if we return to page and away *again*
      this.addTiming('pageHide', timestamp, null);
      this.curSessEndRecorded = true;
    }
  }
  addTiming(name, value, attrs) {
    attrs = attrs || {};
    addConnectionAttributes(attrs); // network conditions may differ from the actual for VitalMetrics when they were captured

    // If cls was set to another value by `onCLS`, then it's supported and is attached onto any timing but is omitted until such time.
    /*
    *cli Apr'23 - Convert attach-to-all -> attach-if-not-null. See NEWRELIC-6143.
    Issue: Because NR 'pageHide' was only sent once with what is considered the "final" CLS value, in the case that 'pageHide' fires before 'load' happens, we incorrectly a final CLS of 0 for that page.
    Mitigation: We've set initial CLS to null so that it's omitted from timings like 'pageHide' in that edge case. It should only be included if onCLS callback was executed at least once.
    Future: onCLS value changes should be reported directly & CLS separated into its own timing node so it's not beholden to 'pageHide' firing. It'd also be possible to report the real final CLS.
    *cli Mar'24 update: CLS now emitted as its own timing node in addition to as-property under other nodes. The 'cls' property is unnecessary for cls nodes.
    */
    if (name !== _constants2.VITAL_NAMES.CUMULATIVE_LAYOUT_SHIFT && _cumulativeLayoutShift.cumulativeLayoutShift.current.value >= 0) {
      attrs.cls = _cumulativeLayoutShift.cumulativeLayoutShift.current.value;
    }
    const timing = {
      name,
      value,
      attrs
    };
    this.events.add(timing);
    (0, _handle.handle)('pvtAdded', [name, value, attrs], undefined, _features.FEATURE_NAMES.sessionTrace, this.ee);
    this.checkForFirstInteraction();

    // makes testing easier
    return timing;
  }

  /**
   * Checks the performance API to see if the agent can set a first interaction event value
   * @returns {void}
   */
  checkForFirstInteraction() {
    // preserve the original behavior where FID is not reported if the page is hidden before the first interaction
    if (this.firstIxnRecorded || _runtime.initiallyHidden || !performance) return;
    const firstInput = performance.getEntriesByType('first-input')[0];
    if (!firstInput) return;
    this.firstIxnRecorded = true;
    this.addTiming('fi', firstInput.startTime, {
      type: firstInput.name,
      eventTarget: (0, _eventOrigin.eventOrigin)(firstInput.target),
      loadState: document.readyState
    });
  }
  appendGlobalCustomAttributes(timing) {
    var timingAttributes = timing.attrs || {};
    var reservedAttributes = ['size', 'eid', 'cls', 'type', 'fid', 'elTag', 'elUrl', 'net-type', 'net-etype', 'net-rtt', 'net-dlink'];
    Object.entries(this.agentRef.info.jsAttributes || {}).forEach(([key, val]) => {
      if (reservedAttributes.indexOf(key) < 0) {
        timingAttributes[key] = val;
      }
    });
  }
  preHarvestChecks() {
    this.checkForFirstInteraction();
    return super.preHarvestChecks();
  }

  // serialize array of timing data
  serializer(eventBuffer) {
    if (!eventBuffer?.length) return '';
    var addString = (0, _belSerializer.getAddStringContext)(this.agentRef.runtime.obfuscator);
    var payload = 'bel.6;';
    for (var i = 0; i < eventBuffer.length; i++) {
      var timing = eventBuffer[i];
      payload += 'e,';
      payload += addString(timing.name) + ',';
      payload += (0, _belSerializer.nullable)(timing.value, _belSerializer.numeric, false) + ',';
      this.appendGlobalCustomAttributes(timing);
      var attrParts = (0, _belSerializer.addCustomAttributes)(timing.attrs, addString);
      if (attrParts && attrParts.length > 0) {
        payload += (0, _belSerializer.numeric)(attrParts.length) + ';' + attrParts.join(';');
      }
      if (i + 1 < eventBuffer.length) payload += ';';
    }
    return payload;
  }
}
exports.Aggregate = Aggregate;
function addConnectionAttributes(obj) {
  var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection; // to date, both window & worker shares the same support for connection
  if (!connection) return;
  if (connection.type) obj['net-type'] = connection.type;
  if (connection.effectiveType) obj['net-etype'] = connection.effectiveType;
  if (connection.rtt) obj['net-rtt'] = connection.rtt;
  if (connection.downlink) obj['net-dlink'] = connection.downlink;
}