"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Aggregate = void 0;
var _runtime = require("../../../common/constants/runtime");
var _navTiming = require("../../../common/timing/nav-timing");
var _stringify = require("../../../common/util/stringify");
var _info = require("../../../common/config/info");
var CONSTANTS = _interopRequireWildcard(require("../constants"));
var _initializedFeatures = require("./initialized-features");
var _featureFlags = require("../../../common/util/feature-flags");
var _console = require("../../../common/util/console");
var _aggregateBase = require("../../utils/aggregate-base");
var _firstContentfulPaint = require("../../../common/vitals/first-contentful-paint");
var _firstPaint = require("../../../common/vitals/first-paint");
var _timeToFirstByte = require("../../../common/vitals/time-to-first-byte");
var _now = require("../../../common/timing/now");
var _timeKeeper = require("../../../common/timing/time-keeper");
var _traverse = require("../../../common/util/traverse");
var _registerHandler = require("../../../common/event-emitter/register-handler");
var _target = require("../../../common/util/target");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

class Aggregate extends _aggregateBase.AggregateBase {
  static featureName = CONSTANTS.FEATURE_NAME;
  constructor(agentRef) {
    super(agentRef, CONSTANTS.FEATURE_NAME);
    this.timeToFirstByte = 0;
    this.firstByteToWindowLoad = 0; // our "frontend" duration
    this.firstByteToDomContent = 0; // our "dom processing" duration

    (0, _registerHandler.registerHandler)('send-rum', (customAttibutes, target) => {
      this.sendRum(customAttibutes, target);
    }, this.featureName, this.ee);
    if (!(0, _info.isValid)(agentRef.info)) {
      this.ee.abort();
      return (0, _console.warn)(43);
    }
    agentRef.runtime.timeKeeper = new _timeKeeper.TimeKeeper(agentRef.runtime.session);
    if (_runtime.isBrowserScope) {
      _timeToFirstByte.timeToFirstByte.subscribe(({
        value,
        attrs
      }) => {
        const navEntry = attrs.navigationEntry;
        this.timeToFirstByte = Math.max(value, this.timeToFirstByte);
        this.firstByteToWindowLoad = Math.max(Math.round(navEntry.loadEventEnd - this.timeToFirstByte), this.firstByteToWindowLoad); // our "frontend" duration
        this.firstByteToDomContent = Math.max(Math.round(navEntry.domContentLoadedEventEnd - this.timeToFirstByte), this.firstByteToDomContent); // our "dom processing" duration

        this.sendRum();
      });
    } else {
      // worker agent build does not get TTFB values, use default 0 values
      this.sendRum();
    }
  }

  /**
   *
   * @param {Function} cb A function to run once the RUM call has finished - Defaults to activateFeatures
   * @param {*} customAttributes custom attributes to attach to the RUM call - Defaults to info.js
   * @param {*} target The target to harvest to - Since we will not know the entityGuid before harvesting, this must be an object directly supplied from the info object or API, not an entityGuid string for lookup with the entityManager - Defaults to { licenseKey: this.agentRef.info.licenseKey, applicationID: this.agentRef.info.applicationID }
   */
  sendRum(customAttributes = this.agentRef.info.jsAttributes, target = {
    licenseKey: this.agentRef.info.licenseKey,
    applicationID: this.agentRef.info.applicationID
  }) {
    const info = this.agentRef.info;
    const measures = {};
    if (info.queueTime) measures.qt = info.queueTime;
    if (info.applicationTime) measures.ap = info.applicationTime;

    // These 3 values should've been recorded after load and before this func runs. They are part of the minimum required for PageView events to be created.
    // Following PR #428, which demands that all agents send RUM call, these need to be sent even outside of the main window context where PerformanceTiming
    // or PerformanceNavigationTiming do not exists. Hence, they'll be filled in by 0s instead in, for example, worker threads that still init the PVE module.
    measures.be = this.timeToFirstByte;
    measures.fe = this.firstByteToWindowLoad;
    measures.dc = this.firstByteToDomContent;
    const queryParameters = {
      tt: info.ttGuid,
      us: info.user,
      ac: info.account,
      pr: info.product,
      af: (0, _initializedFeatures.getActivatedFeaturesFlags)(this.agentIdentifier).join(','),
      ...measures,
      xx: info.extra,
      ua: info.userAttributes,
      at: info.atts
    };
    if (this.agentRef.runtime.session) queryParameters.fsh = Number(this.agentRef.runtime.session.isNew); // "first session harvest" aka RUM request or PageView event of a session

    let body;
    if (typeof customAttributes === 'object' && Object.keys(customAttributes).length > 0) {
      body = (0, _traverse.applyFnToProps)({
        ja: customAttributes
      }, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string');
    }
    if (_runtime.globalScope.performance) {
      if (typeof PerformanceNavigationTiming !== 'undefined') {
        // Navigation Timing level 2 API that replaced PerformanceTiming & PerformanceNavigation
        const navTimingEntry = _runtime.globalScope?.performance?.getEntriesByType('navigation')?.[0];
        const perf = {
          timing: (0, _navTiming.addPT)(_runtime.originTime, navTimingEntry, {}),
          navigation: (0, _navTiming.addPN)(navTimingEntry, {})
        };
        queryParameters.perf = (0, _stringify.stringify)(perf);
      } else if (typeof PerformanceTiming !== 'undefined') {
        // Safari pre-15 did not support level 2 timing
        const perf = {
          timing: (0, _navTiming.addPT)(_runtime.originTime, _runtime.globalScope.performance.timing, {}, true),
          navigation: (0, _navTiming.addPN)(_runtime.globalScope.performance.navigation, {})
        };
        queryParameters.perf = (0, _stringify.stringify)(perf);
      }
    }
    queryParameters.fp = _firstPaint.firstPaint.current.value;
    queryParameters.fcp = _firstContentfulPaint.firstContentfulPaint.current.value;
    const timeKeeper = this.agentRef.runtime.timeKeeper;
    if (timeKeeper?.ready) {
      queryParameters.timestamp = Math.floor(timeKeeper.correctRelativeTimestamp((0, _now.now)()));
    }
    this.rumStartTime = (0, _now.now)();
    this.agentRef.runtime.harvester.triggerHarvestFor(this, {
      directSend: {
        targetApp: target,
        payload: {
          qs: queryParameters,
          body
        }
      },
      needResponse: true,
      sendEmptyBody: true
    });
  }
  postHarvestCleanup({
    status,
    responseText,
    xhr,
    targetApp
  }) {
    const rumEndTime = (0, _now.now)();
    let app, flags;
    try {
      ({
        app,
        ...flags
      } = JSON.parse(responseText));
      this.processEntities(app.agents, targetApp);
    } catch (error) {
      // wont set entity stuff here, if main agent will later abort, if registered agent, nothing will happen
      (0, _console.warn)(53, error);
    }

    /** Only run agent-wide side-effects if the harvest was for the main agent */
    if (!(0, _target.isContainerAgentTarget)(targetApp, this.agentRef)) return;
    if (status >= 400 || status === 0) {
      (0, _console.warn)(18, status);
      // Adding retry logic for the rum call will be a separate change; this.blocked will need to be changed since that prevents another triggerHarvestFor()
      this.ee.abort();
      return;
    }
    try {
      const wasReady = this.agentRef.runtime.timeKeeper.ready;

      // will do nothing if already done
      this.agentRef.runtime.timeKeeper.processRumRequest(xhr, this.rumStartTime, rumEndTime, app.nrServerTime);
      if (!this.agentRef.runtime.timeKeeper.ready) throw new Error('TimeKeeper not ready');

      // If timeKeeper's origin time is ahead of nrServerTime, then the timestamp is invalid. Report a supportability metric.
      const timeDiff = this.agentRef.runtime.timeKeeper.correctedOriginTime - app.nrServerTime;
      if (wasReady && timeDiff > 0) {
        this.reportSupportabilityMetric('Generic/TimeKeeper/InvalidTimestamp/Seen', timeDiff);
      }
    } catch (error) {
      this.ee.abort();
      (0, _console.warn)(17, error);
      return;
    }

    // set the agent runtime objects that require the rum response or entity guid
    if (!Object.keys(this.agentRef.runtime.appMetadata).length) this.agentRef.runtime.appMetadata = app;
    this.drain();
    this.agentRef.runtime.harvester.startTimer();
    (0, _featureFlags.activateFeatures)(flags, this.agentRef);
  }
  processEntities(entities, targetApp) {
    if (!entities || !targetApp) return;
    entities.forEach(agent => {
      const entityManager = this.agentRef.runtime.entityManager;
      const entityGuid = agent.entityGuid;
      const entity = entityManager.get(entityGuid);
      if (entity) return; // already processed

      if ((0, _target.isContainerAgentTarget)(targetApp, this.agentRef)) {
        entityManager.setDefaultEntity({
          ...targetApp,
          entityGuid
        });
      }
      entityManager.set(agent.entityGuid, {
        ...targetApp,
        entityGuid
      });
    });
  }
}
exports.Aggregate = Aggregate;