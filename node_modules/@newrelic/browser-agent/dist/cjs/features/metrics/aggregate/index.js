"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Aggregate = void 0;
var _registerHandler = require("../../../common/event-emitter/register-handler");
var _constants = require("../constants");
var _frameworkDetection = require("./framework-detection");
var _protocol = require("../../../common/url/protocol");
var _load = require("../../../common/window/load");
var _eventListenerOpts = require("../../../common/event-listener/event-listener-opts");
var _runtime = require("../../../common/constants/runtime");
var _aggregateBase = require("../../utils/aggregate-base");
var _iframe = require("../../../common/dom/iframe");
var _harvestMetadata = require("./harvest-metadata");
/**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

// import { WEBSOCKET_TAG } from '../../../common/wrap/wrap-websocket'
// import { handleWebsocketEvents } from './websocket-detection'

class Aggregate extends _aggregateBase.AggregateBase {
  static featureName = _constants.FEATURE_NAME;
  constructor(agentRef) {
    super(agentRef, _constants.FEATURE_NAME);
    this.harvestOpts.aggregatorTypes = ['cm', 'sm']; // the types in EventAggregator this feature cares about

    /** all the harvest metadata metrics need to be evaluated simulataneously at unload time so just temporarily buffer them and dont make SMs immediately from the data */
    this.harvestMetadata = {};
    this.harvestOpts.beforeUnload = () => {
      (0, _harvestMetadata.evaluateHarvestMetadata)(this.harvestMetadata).forEach(smTag => {
        this.storeSupportabilityMetrics(smTag);
      });
    };

    // This feature only harvests once per potential EoL of the page, which is handled by the central harvester.

    // this must be read/stored synchronously, as the currentScript is removed from the DOM after this script is executed and this lookup will be void
    // its used to report a SM later in the lifecycle
    this.agentNonce = _runtime.isBrowserScope && document.currentScript?.nonce;
    this.waitForFlags(['err']).then(([errFlag]) => {
      if (errFlag) {
        this.singleChecks(); // checks that are run only one time, at script load
        this.eachSessionChecks(); // the start of every time user engages with page
        this.drain();
      } else {
        this.blocked = true; // if rum response determines that customer lacks entitlements for spa endpoint, this feature shouldn't harvest
        this.deregisterDrain();
      }
    });

    // Allow features external to the metrics feature to capture SMs and CMs through the event emitter
    (0, _registerHandler.registerHandler)(_constants.SUPPORTABILITY_METRIC_CHANNEL, this.storeSupportabilityMetrics.bind(this), this.featureName, this.ee);
    (0, _registerHandler.registerHandler)(_constants.CUSTOM_METRIC_CHANNEL, this.storeEventMetrics.bind(this), this.featureName, this.ee);
  }
  preHarvestChecks(opts) {
    return this.drained && opts.isFinalHarvest;
  } // only allow any metrics to be sent after we get the right RUM flag and only on EoL

  storeSupportabilityMetrics(name, value) {
    if (this.blocked) return;
    const type = _constants.SUPPORTABILITY_METRIC;
    const params = {
      name
    };
    this.events.addMetric(type, name, params, value);
  }
  storeEventMetrics(name, metrics) {
    if (this.blocked) return;
    const type = _constants.CUSTOM_METRIC;
    const params = {
      name
    };
    this.events.add([type, name, params, metrics]);
  }
  singleChecks() {
    // report loaderType
    const {
      distMethod,
      loaderType
    } = this.agentRef.runtime;
    const {
      proxy,
      privacy
    } = this.agentRef.init;
    if (loaderType) this.storeSupportabilityMetrics("Generic/LoaderType/".concat(loaderType, "/Detected"));
    if (distMethod) this.storeSupportabilityMetrics("Generic/DistMethod/".concat(distMethod, "/Detected"));
    if (_runtime.isBrowserScope) {
      this.storeSupportabilityMetrics('Generic/Runtime/Browser/Detected');
      if (this.agentNonce && this.agentNonce !== '') {
        this.storeSupportabilityMetrics('Generic/Runtime/Nonce/Detected');
      }

      // These SMs are used by the AppExp team
      (0, _load.onDOMContentLoaded)(() => {
        (0, _frameworkDetection.getFrameworks)().forEach(framework => {
          this.storeSupportabilityMetrics('Framework/' + framework + '/Detected');
        });
      });
      if (!privacy.cookies_enabled) this.storeSupportabilityMetrics('Config/SessionTracking/Disabled');
    } else if (_runtime.isWorkerScope) {
      this.storeSupportabilityMetrics('Generic/Runtime/Worker/Detected');
    } else {
      this.storeSupportabilityMetrics('Generic/Runtime/Unknown/Detected');
    }

    // Track if the agent is being loaded using a file protocol such as is the case in some
    // set-top box applications or Electron applications
    if ((0, _protocol.isFileProtocol)()) {
      this.storeSupportabilityMetrics('Generic/FileProtocol/Detected');
    }

    // Capture SMs to assess customer engagement with the obfuscation config
    if (this.obfuscator.obfuscateConfigRules.length > 0) {
      this.storeSupportabilityMetrics('Generic/Obfuscate/Detected');
    }

    // Check if proxy for either chunks or beacon is being used
    if (proxy.assets) this.storeSupportabilityMetrics('Config/AssetsUrl/Changed');
    if (proxy.beacon) this.storeSupportabilityMetrics('Config/BeaconUrl/Changed');
    if (_runtime.isBrowserScope && window.MutationObserver) {
      if ((0, _iframe.isIFrameWindow)(window)) {
        this.storeSupportabilityMetrics('Generic/Runtime/IFrame/Detected');
      }
      const preExistingVideos = window.document.querySelectorAll('video').length;
      if (preExistingVideos) this.storeSupportabilityMetrics('Generic/VideoElement/Added', preExistingVideos);
      const preExistingIframes = window.document.querySelectorAll('iframe').length;
      if (preExistingIframes) this.storeSupportabilityMetrics('Generic/IFrame/Added', preExistingIframes);
      const mo = new MutationObserver(records => {
        records.forEach(record => {
          record.addedNodes.forEach(addedNode => {
            if (addedNode instanceof HTMLVideoElement) {
              this.storeSupportabilityMetrics('Generic/VideoElement/Added', 1);
            }
            if (addedNode instanceof HTMLIFrameElement) {
              this.storeSupportabilityMetrics('Generic/IFrame/Added', 1);
            }
          });
        });
      });
      mo.observe(window.document.body, {
        childList: true,
        subtree: true
      });
    }

    // webdriver detection
    if (navigator.webdriver) this.storeSupportabilityMetrics('Generic/WebDriver/Detected');

    // WATCHABLE_WEB_SOCKET_EVENTS.forEach(tag => {
    //   registerHandler('buffered-' + WEBSOCKET_TAG + tag, (...args) => {
    //     handleWebsocketEvents(this.storeSupportabilityMetrics.bind(this), tag, ...args)
    //   }, this.featureName, this.ee)
    // })

    /** all the harvest metadata metrics need to be evaluated simulataneously at unload time so just temporarily buffer them and dont make SMs immediately from the data */
    (0, _registerHandler.registerHandler)('harvest-metadata', (harvestMetadataObject = {}) => {
      try {
        Object.keys(harvestMetadataObject).forEach(key => {
          Object.assign(this.harvestMetadata[key] ??= {}, harvestMetadataObject[key]);
        });
      } catch (e) {
        // failed to merge harvest metadata... ignore
      }
    }, this.featureName, this.ee);
  }
  eachSessionChecks() {
    if (!_runtime.isBrowserScope) return;

    // [Temporary] Report restores from BFCache to NR1 while feature flag is in place in lieu of sending pageshow events.
    (0, _eventListenerOpts.windowAddEventListener)('pageshow', evt => {
      if (evt?.persisted) {
        this.storeSupportabilityMetrics('Generic/BFCache/PageRestored');
      }
    });
  }
}
exports.Aggregate = Aggregate;