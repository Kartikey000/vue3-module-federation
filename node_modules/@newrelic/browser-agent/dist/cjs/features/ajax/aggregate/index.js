"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Aggregate = void 0;
var _registerHandler = require("../../../common/event-emitter/register-handler");
var _stringify = require("../../../common/util/stringify");
var _handle = require("../../../common/event-emitter/handle");
var _denyList = require("../../../common/deny-list/deny-list");
var _constants = require("../constants");
var _features = require("../../../loaders/features/features");
var _aggregateBase = require("../../utils/aggregate-base");
var _gql = require("./gql");
var _belSerializer = require("../../../common/serialize/bel-serializer");
var _nreum = require("../../../common/window/nreum");
/**
 * Copyright 2020-2025 New Relic, Inc. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

class Aggregate extends _aggregateBase.AggregateBase {
  static featureName = _constants.FEATURE_NAME;
  constructor(agentRef) {
    super(agentRef, _constants.FEATURE_NAME);
    (0, _denyList.setDenyList)(agentRef.runtime.denyList);
    this.underSpaEvents = {};
    const classThis = this;
    if (!agentRef.init.ajax.block_internal) {
      // if the agent is tracking ITSELF, it can spawn endless ajax requests early if they are large from custom attributes, so we just disable early harvest for ajax in this case.
      super.canHarvestEarly = false;
    } else {
      super.customAttributesAreSeparate = true;
    }

    // --- v Used by old spa feature
    this.ee.on('interactionDone', (interaction, wasSaved) => {
      if (!this.underSpaEvents[interaction.id]) return;
      if (!wasSaved) {
        // if the ixn was saved, then its ajax reqs are part of the payload whereas if it was discarded, it should still be harvested in the ajax feature itself
        this.underSpaEvents[interaction.id].forEach(item => this.events.add(item));
      }
      delete this.underSpaEvents[interaction.id];
    });
    // --- ^
    // --- v Used by new soft nav
    (0, _registerHandler.registerHandler)('returnAjax', event => this.events.add(event), this.featureName, this.ee);
    // --- ^
    (0, _registerHandler.registerHandler)('xhr', function () {
      // the EE-drain system not only switches "this" but also passes a new EventContext with info. Should consider platform refactor to another system which passes a mutable context around separately and predictably to avoid problems like this.
      classThis.storeXhr(...arguments, this); // this switches the context back to the class instance while passing the NR context as an argument -- see "ctx" in storeXhr
    }, this.featureName, this.ee);
    this.ee.on('long-task', (task, originator) => {
      if (originator instanceof (0, _nreum.gosNREUMOriginals)().o.XHR) {
        // any time a long task from XHR callback is observed, update the end time for soft nav use
        const xhrMetadata = this.ee.context(originator);
        xhrMetadata.latestLongtaskEnd = task.end;
      }
    });
    this.waitForFlags([]).then(() => this.drain());
  }
  storeXhr(params, metrics, startTime, endTime, type, ctx) {
    metrics.time = startTime;

    // send to session traces
    let hash;
    if (params.cat) {
      hash = (0, _stringify.stringify)([params.status, params.cat]);
    } else {
      hash = (0, _stringify.stringify)([params.status, params.host, params.pathname]);
    }
    const shouldCollect = (0, _denyList.shouldCollectEvent)(params);
    const shouldOmitAjaxMetrics = this.agentRef.init.feature_flags?.includes('ajax_metrics_deny_list');
    const jserrorsInUse = Boolean(this.agentRef.features?.[_features.FEATURE_NAMES.jserrors]);

    // Report ajax timeslice metric (to be harvested by jserrors feature, but only if it's running).
    if (jserrorsInUse && (shouldCollect || !shouldOmitAjaxMetrics)) {
      this.agentRef.sharedAggregator?.add(['xhr', hash, params, metrics]);
    }
    if (!shouldCollect) {
      if (params.hostname === this.agentRef.info.errorBeacon || this.agentRef.init.proxy?.beacon && params.hostname === this.agentRef.init.proxy.beacon) {
        // This doesn't make a distinction if the same-domain request is going to a different port or path...
        this.reportSupportabilityMetric('Ajax/Events/Excluded/Agent');
        if (shouldOmitAjaxMetrics) this.reportSupportabilityMetric('Ajax/Metrics/Excluded/Agent');
      } else {
        this.reportSupportabilityMetric('Ajax/Events/Excluded/App');
        if (shouldOmitAjaxMetrics) this.reportSupportabilityMetric('Ajax/Metrics/Excluded/App');
      }
      return; // do not send this ajax as an event
    }
    (0, _handle.handle)('bstXhrAgg', ['xhr', hash, params, metrics], undefined, _features.FEATURE_NAMES.sessionTrace, this.ee); // have trace feature harvest AjaxNode

    const event = {
      method: params.method,
      status: params.status,
      domain: params.host,
      path: params.pathname,
      requestSize: metrics.txSize,
      responseSize: metrics.rxSize,
      type,
      startTime,
      endTime,
      callbackDuration: metrics.cbTime
    };
    if (ctx.dt) {
      event.spanId = ctx.dt.spanId;
      event.traceId = ctx.dt.traceId;
      event.spanTimestamp = Math.floor(this.agentRef.runtime.timeKeeper.correctAbsoluteTimestamp(ctx.dt.timestamp));
    }

    // parsed from the AJAX body, looking for operationName param & parsing query for operationType
    event.gql = params.gql = (0, _gql.parseGQL)({
      body: ctx.body,
      query: ctx.parsedOrigin?.search
    });
    if (event.gql) this.reportSupportabilityMetric('Ajax/Events/GraphQL/Bytes-Added', (0, _stringify.stringify)(event.gql).length);
    const softNavInUse = Boolean(this.agentRef.features?.[_features.FEATURE_NAMES.softNav]);
    if (softNavInUse) {
      // For newer soft nav (when running), pass the event w/ info to it for evaluation -- either part of an interaction or is given back
      (0, _handle.handle)('ajax', [event, ctx], undefined, _features.FEATURE_NAMES.softNav, this.ee);
    } else if (ctx.spaNode) {
      // For old spa (when running), if the ajax happened inside an interaction, hold it until the interaction finishes
      const interactionId = ctx.spaNode.interaction.id;
      this.underSpaEvents[interactionId] ??= [];
      this.underSpaEvents[interactionId].push(event);
    } else {
      this.events.add(event);
    }
  }
  serializer(eventBuffer) {
    if (!eventBuffer.length) return;
    const addString = (0, _belSerializer.getAddStringContext)(this.agentRef.runtime.obfuscator);
    let payload = 'bel.7;';
    for (let i = 0; i < eventBuffer.length; i++) {
      const event = eventBuffer[i];
      const fields = [(0, _belSerializer.numeric)(event.startTime), (0, _belSerializer.numeric)(event.endTime - event.startTime), (0, _belSerializer.numeric)(0),
      // callbackEnd
      (0, _belSerializer.numeric)(0),
      // no callbackDuration for non-SPA events
      addString(event.method), (0, _belSerializer.numeric)(event.status), addString(event.domain), addString(event.path), (0, _belSerializer.numeric)(event.requestSize), (0, _belSerializer.numeric)(event.responseSize), event.type === 'fetch' ? 1 : '', addString(0),
      // nodeId
      (0, _belSerializer.nullable)(event.spanId, addString, true) +
      // guid
      (0, _belSerializer.nullable)(event.traceId, addString, true) +
      // traceId
      (0, _belSerializer.nullable)(event.spanTimestamp, _belSerializer.numeric, false) // timestamp
      ];
      let insert = '2,';

      // Since configuration objects (like info) are created new each time they are set, we have to grab the current pointer to the attr object here.
      const jsAttributes = this.agentRef.info.jsAttributes;

      // add custom attributes
      // gql decorators are added as custom attributes to alleviate need for new BEL schema
      const attrParts = (0, _belSerializer.addCustomAttributes)({
        ...(jsAttributes || {}),
        ...(event.gql || {})
      }, addString);
      fields.unshift((0, _belSerializer.numeric)(attrParts.length));
      insert += fields.join(',');
      if (attrParts && attrParts.length > 0) {
        insert += ';' + attrParts.join(';');
      }
      if (i + 1 < eventBuffer.length) insert += ';';
      payload += insert;
    }
    return payload;
  }
}
exports.Aggregate = Aggregate;